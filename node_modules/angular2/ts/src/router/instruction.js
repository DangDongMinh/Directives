System.register(['angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/facade/async'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var collection_1, lang_1, async_1;
    var RouteParams, RouteData, BLANK_ROUTE_DATA, Instruction, ResolvedInstruction, DefaultInstruction, UnresolvedInstruction, RedirectInstruction, ComponentInstruction;
    return {
        setters:[
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (async_1_1) {
                async_1 = async_1_1;
            }],
        execute: function() {
            /**
             * `RouteParams` is an immutable map of parameters for the given route
             * based on the url matcher and optional parameters for that route.
             *
             * You can inject `RouteParams` into the constructor of a component to use it.
             *
             * ### Example
             *
             * ```
             * import {Component} from 'angular2/core';
             * import {bootstrap} from 'angular2/platform/browser';
             * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig, RouteParams} from
             * 'angular2/router';
             *
             * @Component({directives: [ROUTER_DIRECTIVES]})
             * @RouteConfig([
             *  {path: '/user/:id', component: UserCmp, name: 'UserCmp'},
             * ])
             * class AppCmp {}
             *
             * @Component({ template: 'user: {{id}}' })
             * class UserCmp {
             *   id: string;
             *   constructor(params: RouteParams) {
             *     this.id = params.get('id');
             *   }
             * }
             *
             * bootstrap(AppCmp, ROUTER_PROVIDERS);
             * ```
             */
            class RouteParams {
                constructor(params) {
                    this.params = params;
                }
                get(param) { return lang_1.normalizeBlank(collection_1.StringMapWrapper.get(this.params, param)); }
            }
            exports_1("RouteParams", RouteParams);
            /**
             * `RouteData` is an immutable map of additional data you can configure in your {@link Route}.
             *
             * You can inject `RouteData` into the constructor of a component to use it.
             *
             * ### Example
             *
             * ```
             * import {Component} from 'angular2/core';
             * import {bootstrap} from 'angular2/platform/browser';
             * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig, RouteData} from
             * 'angular2/router';
             *
             * @Component({directives: [ROUTER_DIRECTIVES]})
             * @RouteConfig([
             *  {path: '/user/:id', component: UserCmp, name: 'UserCmp', data: {isAdmin: true}},
             * ])
             * class AppCmp {}
             *
             * @Component({...})
             * @View({ template: 'user: {{isAdmin}}' })
             * class UserCmp {
             *   string: isAdmin;
             *   constructor(data: RouteData) {
             *     this.isAdmin = data.get('isAdmin');
             *   }
             * }
             *
             * bootstrap(AppCmp, ROUTER_PROVIDERS);
             * ```
             */
            class RouteData {
                constructor(data = lang_1.CONST_EXPR({})) {
                    this.data = data;
                }
                get(key) { return lang_1.normalizeBlank(collection_1.StringMapWrapper.get(this.data, key)); }
            }
            exports_1("RouteData", RouteData);
            exports_1("BLANK_ROUTE_DATA", BLANK_ROUTE_DATA = new RouteData());
            /**
             * `Instruction` is a tree of {@link ComponentInstruction}s with all the information needed
             * to transition each component in the app to a given route, including all auxiliary routes.
             *
             * `Instruction`s can be created using {@link Router#generate}, and can be used to
             * perform route changes with {@link Router#navigateByInstruction}.
             *
             * ### Example
             *
             * ```
             * import {Component} from 'angular2/core';
             * import {bootstrap} from 'angular2/platform/browser';
             * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
             *
             * @Component({directives: [ROUTER_DIRECTIVES]})
             * @RouteConfig([
             *  {...},
             * ])
             * class AppCmp {
             *   constructor(router: Router) {
             *     var instruction = router.generate(['/MyRoute']);
             *     router.navigateByInstruction(instruction);
             *   }
             * }
             *
             * bootstrap(AppCmp, ROUTER_PROVIDERS);
             * ```
             */
            class Instruction {
                constructor(component, child, auxInstruction) {
                    this.component = component;
                    this.child = child;
                    this.auxInstruction = auxInstruction;
                }
                get urlPath() { return lang_1.isPresent(this.component) ? this.component.urlPath : ''; }
                get urlParams() { return lang_1.isPresent(this.component) ? this.component.urlParams : []; }
                get specificity() {
                    var total = '';
                    if (lang_1.isPresent(this.component)) {
                        total += this.component.specificity;
                    }
                    if (lang_1.isPresent(this.child)) {
                        total += this.child.specificity;
                    }
                    return total;
                }
                /**
                 * converts the instruction into a URL string
                 */
                toRootUrl() { return this.toUrlPath() + this.toUrlQuery(); }
                /** @internal */
                _toNonRootUrl() {
                    return this._stringifyPathMatrixAuxPrefixed() +
                        (lang_1.isPresent(this.child) ? this.child._toNonRootUrl() : '');
                }
                toUrlQuery() { return this.urlParams.length > 0 ? ('?' + this.urlParams.join('&')) : ''; }
                /**
                 * Returns a new instruction that shares the state of the existing instruction, but with
                 * the given child {@link Instruction} replacing the existing child.
                 */
                replaceChild(child) {
                    return new ResolvedInstruction(this.component, child, this.auxInstruction);
                }
                /**
                 * If the final URL for the instruction is ``
                 */
                toUrlPath() {
                    return this.urlPath + this._stringifyAux() +
                        (lang_1.isPresent(this.child) ? this.child._toNonRootUrl() : '');
                }
                // default instructions override these
                toLinkUrl() {
                    return this.urlPath + this._stringifyAux() +
                        (lang_1.isPresent(this.child) ? this.child._toLinkUrl() : '');
                }
                // this is the non-root version (called recursively)
                /** @internal */
                _toLinkUrl() {
                    return this._stringifyPathMatrixAuxPrefixed() +
                        (lang_1.isPresent(this.child) ? this.child._toLinkUrl() : '');
                }
                /** @internal */
                _stringifyPathMatrixAuxPrefixed() {
                    var primary = this._stringifyPathMatrixAux();
                    if (primary.length > 0) {
                        primary = '/' + primary;
                    }
                    return primary;
                }
                /** @internal */
                _stringifyMatrixParams() {
                    return this.urlParams.length > 0 ? (';' + this.urlParams.join(';')) : '';
                }
                /** @internal */
                _stringifyPathMatrixAux() {
                    if (lang_1.isBlank(this.component)) {
                        return '';
                    }
                    return this.urlPath + this._stringifyMatrixParams() + this._stringifyAux();
                }
                /** @internal */
                _stringifyAux() {
                    var routes = [];
                    collection_1.StringMapWrapper.forEach(this.auxInstruction, (auxInstruction, _) => {
                        routes.push(auxInstruction._stringifyPathMatrixAux());
                    });
                    if (routes.length > 0) {
                        return '(' + routes.join('//') + ')';
                    }
                    return '';
                }
            }
            exports_1("Instruction", Instruction);
            /**
             * a resolved instruction has an outlet instruction for itself, but maybe not for...
             */
            class ResolvedInstruction extends Instruction {
                constructor(component, child, auxInstruction) {
                    super(component, child, auxInstruction);
                }
                resolveComponent() {
                    return async_1.PromiseWrapper.resolve(this.component);
                }
            }
            exports_1("ResolvedInstruction", ResolvedInstruction);
            /**
             * Represents a resolved default route
             */
            class DefaultInstruction extends Instruction {
                constructor(component, child) {
                    super(component, child, {});
                }
                resolveComponent() {
                    return async_1.PromiseWrapper.resolve(this.component);
                }
                toLinkUrl() { return ''; }
                /** @internal */
                _toLinkUrl() { return ''; }
            }
            exports_1("DefaultInstruction", DefaultInstruction);
            /**
             * Represents a component that may need to do some redirection or lazy loading at a later time.
             */
            class UnresolvedInstruction extends Instruction {
                constructor(_resolver, _urlPath = '', _urlParams = lang_1.CONST_EXPR([])) {
                    super(null, null, {});
                    this._resolver = _resolver;
                    this._urlPath = _urlPath;
                    this._urlParams = _urlParams;
                }
                get urlPath() {
                    if (lang_1.isPresent(this.component)) {
                        return this.component.urlPath;
                    }
                    if (lang_1.isPresent(this._urlPath)) {
                        return this._urlPath;
                    }
                    return '';
                }
                get urlParams() {
                    if (lang_1.isPresent(this.component)) {
                        return this.component.urlParams;
                    }
                    if (lang_1.isPresent(this._urlParams)) {
                        return this._urlParams;
                    }
                    return [];
                }
                resolveComponent() {
                    if (lang_1.isPresent(this.component)) {
                        return async_1.PromiseWrapper.resolve(this.component);
                    }
                    return this._resolver().then((resolution) => {
                        this.child = resolution.child;
                        return this.component = resolution.component;
                    });
                }
            }
            exports_1("UnresolvedInstruction", UnresolvedInstruction);
            class RedirectInstruction extends ResolvedInstruction {
                constructor(component, child, auxInstruction, _specificity) {
                    super(component, child, auxInstruction);
                    this._specificity = _specificity;
                }
                get specificity() { return this._specificity; }
            }
            exports_1("RedirectInstruction", RedirectInstruction);
            /**
             * A `ComponentInstruction` represents the route state for a single component. An `Instruction` is
             * composed of a tree of these `ComponentInstruction`s.
             *
             * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed
             * to route lifecycle hooks, like {@link CanActivate}.
             *
             * `ComponentInstruction`s are [hash consed](https://en.wikipedia.org/wiki/Hash_consing). You should
             * never construct one yourself with "new." Instead, rely on {@link Router/RouteRecognizer} to
             * construct `ComponentInstruction`s.
             *
             * You should not modify this object. It should be treated as immutable.
             */
            class ComponentInstruction {
                constructor(urlPath, urlParams, data, componentType, terminal, specificity, params = null) {
                    this.urlPath = urlPath;
                    this.urlParams = urlParams;
                    this.componentType = componentType;
                    this.terminal = terminal;
                    this.specificity = specificity;
                    this.params = params;
                    this.reuse = false;
                    this.routeData = lang_1.isPresent(data) ? data : BLANK_ROUTE_DATA;
                }
            }
            exports_1("ComponentInstruction", ComponentInstruction);
        }
    }
});
//# sourceMappingURL=instruction.js.map
System.register(['angular2/src/facade/lang', 'angular2/src/facade/exceptions', 'angular2/src/facade/promise', 'angular2/src/facade/collection', './instruction', './path_recognizer'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var lang_1, exceptions_1, promise_1, collection_1, instruction_1, path_recognizer_1;
    var RouteMatch, PathMatch, RedirectMatch, RedirectRecognizer, RouteRecognizer;
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (exceptions_1_1) {
                exceptions_1 = exceptions_1_1;
            },
            function (promise_1_1) {
                promise_1 = promise_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (instruction_1_1) {
                instruction_1 = instruction_1_1;
            },
            function (path_recognizer_1_1) {
                path_recognizer_1 = path_recognizer_1_1;
            }],
        execute: function() {
            class RouteMatch {
            }
            exports_1("RouteMatch", RouteMatch);
            class PathMatch extends RouteMatch {
                constructor(instruction, remaining, remainingAux) {
                    super();
                    this.instruction = instruction;
                    this.remaining = remaining;
                    this.remainingAux = remainingAux;
                }
            }
            exports_1("PathMatch", PathMatch);
            class RedirectMatch extends RouteMatch {
                constructor(redirectTo, specificity) {
                    super();
                    this.redirectTo = redirectTo;
                    this.specificity = specificity;
                }
            }
            exports_1("RedirectMatch", RedirectMatch);
            class RedirectRecognizer {
                constructor(path, redirectTo) {
                    this.path = path;
                    this.redirectTo = redirectTo;
                    this._pathRecognizer = new path_recognizer_1.PathRecognizer(path);
                    this.hash = this._pathRecognizer.hash;
                }
                /**
                 * Returns `null` or a `ParsedUrl` representing the new path to match
                 */
                recognize(beginningSegment) {
                    var match = null;
                    if (lang_1.isPresent(this._pathRecognizer.recognize(beginningSegment))) {
                        match = new RedirectMatch(this.redirectTo, this._pathRecognizer.specificity);
                    }
                    return promise_1.PromiseWrapper.resolve(match);
                }
                generate(params) {
                    throw new exceptions_1.BaseException(`Tried to generate a redirect.`);
                }
            }
            exports_1("RedirectRecognizer", RedirectRecognizer);
            // represents something like '/foo/:bar'
            class RouteRecognizer {
                // TODO: cache component instruction instances by params and by ParsedUrl instance
                constructor(path, handler) {
                    this.path = path;
                    this.handler = handler;
                    this.terminal = true;
                    this._cache = new collection_1.Map();
                    this._pathRecognizer = new path_recognizer_1.PathRecognizer(path);
                    this.specificity = this._pathRecognizer.specificity;
                    this.hash = this._pathRecognizer.hash;
                    this.terminal = this._pathRecognizer.terminal;
                }
                recognize(beginningSegment) {
                    var res = this._pathRecognizer.recognize(beginningSegment);
                    if (lang_1.isBlank(res)) {
                        return null;
                    }
                    return this.handler.resolveComponentType().then((_) => {
                        var componentInstruction = this._getInstruction(res['urlPath'], res['urlParams'], res['allParams']);
                        return new PathMatch(componentInstruction, res['nextSegment'], res['auxiliary']);
                    });
                }
                generate(params) {
                    var generated = this._pathRecognizer.generate(params);
                    var urlPath = generated['urlPath'];
                    var urlParams = generated['urlParams'];
                    return this._getInstruction(urlPath, urlParams, params);
                }
                generateComponentPathValues(params) {
                    return this._pathRecognizer.generate(params);
                }
                _getInstruction(urlPath, urlParams, params) {
                    if (lang_1.isBlank(this.handler.componentType)) {
                        throw new exceptions_1.BaseException(`Tried to get instruction before the type was loaded.`);
                    }
                    var hashKey = urlPath + '?' + urlParams.join('?');
                    if (this._cache.has(hashKey)) {
                        return this._cache.get(hashKey);
                    }
                    var instruction = new instruction_1.ComponentInstruction(urlPath, urlParams, this.handler.data, this.handler.componentType, this.terminal, this.specificity, params);
                    this._cache.set(hashKey, instruction);
                    return instruction;
                }
            }
            exports_1("RouteRecognizer", RouteRecognizer);
        }
    }
});
//# sourceMappingURL=route_recognizer.js.map
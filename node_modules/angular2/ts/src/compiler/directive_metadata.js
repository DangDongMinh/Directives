System.register(['angular2/src/facade/lang', 'angular2/src/facade/exceptions', 'angular2/src/facade/collection', 'angular2/src/core/change_detection/change_detection', 'angular2/src/core/metadata/view', 'angular2/src/compiler/selector', './util', 'angular2/src/core/linker/interfaces'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var lang_1, exceptions_1, collection_1, change_detection_1, view_1, selector_1, util_1, interfaces_1;
    var HOST_REG_EXP, CompileMetadataWithType, CompileTypeMetadata, CompileTemplateMetadata, CompileDirectiveMetadata, CompilePipeMetadata, _COMPILE_METADATA_FROM_JSON;
    /**
     * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
     */
    function createHostComponentMeta(componentType, componentSelector) {
        var template = selector_1.CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();
        return CompileDirectiveMetadata.create({
            type: new CompileTypeMetadata({
                runtime: Object,
                name: `Host${componentType.name}`,
                moduleUrl: componentType.moduleUrl,
                isHost: true
            }),
            template: new CompileTemplateMetadata({ template: template, templateUrl: '', styles: [], styleUrls: [], ngContentSelectors: [] }),
            changeDetection: change_detection_1.ChangeDetectionStrategy.Default,
            inputs: [],
            outputs: [],
            host: {},
            lifecycleHooks: [],
            isComponent: true,
            dynamicLoadable: false,
            selector: '*'
        });
    }
    exports_1("createHostComponentMeta", createHostComponentMeta);
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (exceptions_1_1) {
                exceptions_1 = exceptions_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (change_detection_1_1) {
                change_detection_1 = change_detection_1_1;
            },
            function (view_1_1) {
                view_1 = view_1_1;
            },
            function (selector_1_1) {
                selector_1 = selector_1_1;
            },
            function (util_1_1) {
                util_1 = util_1_1;
            },
            function (interfaces_1_1) {
                interfaces_1 = interfaces_1_1;
            }],
        execute: function() {
            // group 1: "property" from "[property]"
            // group 2: "event" from "(event)"
            HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
            class CompileMetadataWithType {
                static fromJson(data) {
                    return _COMPILE_METADATA_FROM_JSON[data['class']](data);
                }
                get type() { return exceptions_1.unimplemented(); }
            }
            exports_1("CompileMetadataWithType", CompileMetadataWithType);
            /**
             * Metadata regarding compilation of a type.
             */
            class CompileTypeMetadata {
                constructor({ runtime, name, moduleUrl, isHost } = {}) {
                    this.runtime = runtime;
                    this.name = name;
                    this.moduleUrl = moduleUrl;
                    this.isHost = lang_1.normalizeBool(isHost);
                }
                static fromJson(data) {
                    return new CompileTypeMetadata({ name: data['name'], moduleUrl: data['moduleUrl'], isHost: data['isHost'] });
                }
                toJson() {
                    return {
                        // Note: Runtime type can't be serialized...
                        'name': this.name,
                        'moduleUrl': this.moduleUrl,
                        'isHost': this.isHost
                    };
                }
            }
            exports_1("CompileTypeMetadata", CompileTypeMetadata);
            /**
             * Metadata regarding compilation of a template.
             */
            class CompileTemplateMetadata {
                constructor({ encapsulation, template, templateUrl, styles, styleUrls, ngContentSelectors } = {}) {
                    this.encapsulation = lang_1.isPresent(encapsulation) ? encapsulation : view_1.ViewEncapsulation.Emulated;
                    this.template = template;
                    this.templateUrl = templateUrl;
                    this.styles = lang_1.isPresent(styles) ? styles : [];
                    this.styleUrls = lang_1.isPresent(styleUrls) ? styleUrls : [];
                    this.ngContentSelectors = lang_1.isPresent(ngContentSelectors) ? ngContentSelectors : [];
                }
                static fromJson(data) {
                    return new CompileTemplateMetadata({
                        encapsulation: lang_1.isPresent(data['encapsulation']) ?
                            view_1.VIEW_ENCAPSULATION_VALUES[data['encapsulation']] :
                            data['encapsulation'],
                        template: data['template'],
                        templateUrl: data['templateUrl'],
                        styles: data['styles'],
                        styleUrls: data['styleUrls'],
                        ngContentSelectors: data['ngContentSelectors']
                    });
                }
                toJson() {
                    return {
                        'encapsulation': lang_1.isPresent(this.encapsulation) ? lang_1.serializeEnum(this.encapsulation) : this.encapsulation,
                        'template': this.template,
                        'templateUrl': this.templateUrl,
                        'styles': this.styles,
                        'styleUrls': this.styleUrls,
                        'ngContentSelectors': this.ngContentSelectors
                    };
                }
            }
            exports_1("CompileTemplateMetadata", CompileTemplateMetadata);
            /**
             * Metadata regarding compilation of a directive.
             */
            class CompileDirectiveMetadata {
                constructor({ type, isComponent, dynamicLoadable, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, lifecycleHooks, template } = {}) {
                    this.type = type;
                    this.isComponent = isComponent;
                    this.dynamicLoadable = dynamicLoadable;
                    this.selector = selector;
                    this.exportAs = exportAs;
                    this.changeDetection = changeDetection;
                    this.inputs = inputs;
                    this.outputs = outputs;
                    this.hostListeners = hostListeners;
                    this.hostProperties = hostProperties;
                    this.hostAttributes = hostAttributes;
                    this.lifecycleHooks = lifecycleHooks;
                    this.template = template;
                }
                static create({ type, isComponent, dynamicLoadable, selector, exportAs, changeDetection, inputs, outputs, host, lifecycleHooks, template } = {}) {
                    var hostListeners = {};
                    var hostProperties = {};
                    var hostAttributes = {};
                    if (lang_1.isPresent(host)) {
                        collection_1.StringMapWrapper.forEach(host, (value, key) => {
                            var matches = lang_1.RegExpWrapper.firstMatch(HOST_REG_EXP, key);
                            if (lang_1.isBlank(matches)) {
                                hostAttributes[key] = value;
                            }
                            else if (lang_1.isPresent(matches[1])) {
                                hostProperties[matches[1]] = value;
                            }
                            else if (lang_1.isPresent(matches[2])) {
                                hostListeners[matches[2]] = value;
                            }
                        });
                    }
                    var inputsMap = {};
                    if (lang_1.isPresent(inputs)) {
                        inputs.forEach((bindConfig) => {
                            // canonical syntax: `dirProp: elProp`
                            // if there is no `:`, use dirProp = elProp
                            var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                            inputsMap[parts[0]] = parts[1];
                        });
                    }
                    var outputsMap = {};
                    if (lang_1.isPresent(outputs)) {
                        outputs.forEach((bindConfig) => {
                            // canonical syntax: `dirProp: elProp`
                            // if there is no `:`, use dirProp = elProp
                            var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                            outputsMap[parts[0]] = parts[1];
                        });
                    }
                    return new CompileDirectiveMetadata({
                        type: type,
                        isComponent: lang_1.normalizeBool(isComponent),
                        dynamicLoadable: lang_1.normalizeBool(dynamicLoadable),
                        selector: selector,
                        exportAs: exportAs,
                        changeDetection: changeDetection,
                        inputs: inputsMap,
                        outputs: outputsMap,
                        hostListeners: hostListeners,
                        hostProperties: hostProperties,
                        hostAttributes: hostAttributes,
                        lifecycleHooks: lang_1.isPresent(lifecycleHooks) ? lifecycleHooks : [],
                        template: template
                    });
                }
                static fromJson(data) {
                    return new CompileDirectiveMetadata({
                        isComponent: data['isComponent'],
                        dynamicLoadable: data['dynamicLoadable'],
                        selector: data['selector'],
                        exportAs: data['exportAs'],
                        type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
                        changeDetection: lang_1.isPresent(data['changeDetection']) ?
                            change_detection_1.CHANGE_DETECTION_STRATEGY_VALUES[data['changeDetection']] :
                            data['changeDetection'],
                        inputs: data['inputs'],
                        outputs: data['outputs'],
                        hostListeners: data['hostListeners'],
                        hostProperties: data['hostProperties'],
                        hostAttributes: data['hostAttributes'],
                        lifecycleHooks: data['lifecycleHooks'].map(hookValue => interfaces_1.LIFECYCLE_HOOKS_VALUES[hookValue]),
                        template: lang_1.isPresent(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) :
                            data['template']
                    });
                }
                toJson() {
                    return {
                        'class': 'Directive',
                        'isComponent': this.isComponent,
                        'dynamicLoadable': this.dynamicLoadable,
                        'selector': this.selector,
                        'exportAs': this.exportAs,
                        'type': lang_1.isPresent(this.type) ? this.type.toJson() : this.type,
                        'changeDetection': lang_1.isPresent(this.changeDetection) ? lang_1.serializeEnum(this.changeDetection) :
                            this.changeDetection,
                        'inputs': this.inputs,
                        'outputs': this.outputs,
                        'hostListeners': this.hostListeners,
                        'hostProperties': this.hostProperties,
                        'hostAttributes': this.hostAttributes,
                        'lifecycleHooks': this.lifecycleHooks.map(hook => lang_1.serializeEnum(hook)),
                        'template': lang_1.isPresent(this.template) ? this.template.toJson() : this.template
                    };
                }
            }
            exports_1("CompileDirectiveMetadata", CompileDirectiveMetadata);
            class CompilePipeMetadata {
                constructor({ type, name, pure } = {}) {
                    this.type = type;
                    this.name = name;
                    this.pure = lang_1.normalizeBool(pure);
                }
                static fromJson(data) {
                    return new CompilePipeMetadata({
                        type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
                        name: data['name'],
                        pure: data['pure']
                    });
                }
                toJson() {
                    return {
                        'class': 'Pipe',
                        'type': lang_1.isPresent(this.type) ? this.type.toJson() : null,
                        'name': this.name,
                        'pure': this.pure
                    };
                }
            }
            exports_1("CompilePipeMetadata", CompilePipeMetadata);
            _COMPILE_METADATA_FROM_JSON = {
                'Directive': CompileDirectiveMetadata.fromJson,
                'Pipe': CompilePipeMetadata.fromJson
            };
        }
    }
});
//# sourceMappingURL=directive_metadata.js.map
System.register(['angular2/src/facade/lang', 'angular2/src/facade/collection', './template_ast', './source_module', 'angular2/src/core/linker/view', 'angular2/src/core/linker/view_type', 'angular2/src/core/linker/element', 'angular2/src/core/metadata/view', './util', 'angular2/src/core/di', './proto_view_compiler'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var lang_1, collection_1, template_ast_1, source_module_1, view_1, view_type_1, element_1, view_2, util_1, di_1, proto_view_compiler_1;
    var VIEW_JIT_IMPORTS, ViewCompiler, CodeGenViewFactory, RuntimeViewFactory, ParentElement, ViewBuilderVisitor;
    function codeGenEventHandler(view, boundElementIndex, eventName) {
        return util_1.codeGenValueFn(['event'], `${view.expression}.triggerEventHandlers(${util_1.escapeValue(eventName)}, event, ${boundElementIndex})`);
    }
    function codeGenViewFactoryName(component, embeddedTemplateIndex) {
        return `viewFactory_${component.type.name}${embeddedTemplateIndex}`;
    }
    function codeGenViewEncapsulation(value) {
        if (lang_1.IS_DART) {
            return `${proto_view_compiler_1.METADATA_MODULE_REF}${value}`;
        }
        else {
            return `${value}`;
        }
    }
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (template_ast_1_1) {
                template_ast_1 = template_ast_1_1;
            },
            function (source_module_1_1) {
                source_module_1 = source_module_1_1;
            },
            function (view_1_1) {
                view_1 = view_1_1;
            },
            function (view_type_1_1) {
                view_type_1 = view_type_1_1;
            },
            function (element_1_1) {
                element_1 = element_1_1;
            },
            function (view_2_1) {
                view_2 = view_2_1;
            },
            function (util_1_1) {
                util_1 = util_1_1;
            },
            function (di_1_1) {
                di_1 = di_1_1;
            },
            function (proto_view_compiler_1_1) {
                proto_view_compiler_1 = proto_view_compiler_1_1;
            }],
        execute: function() {
            exports_1("VIEW_JIT_IMPORTS", VIEW_JIT_IMPORTS = lang_1.CONST_EXPR({
                'AppView': view_1.AppView,
                'AppElement': element_1.AppElement,
                'flattenNestedViewRenderNodes': view_1.flattenNestedViewRenderNodes,
                'checkSlotCount': view_1.checkSlotCount
            }));
            let ViewCompiler = class ViewCompiler {
                constructor() {
                }
                compileComponentRuntime(component, template, styles, protoViews, changeDetectorFactories, componentViewFactory) {
                    var viewFactory = new RuntimeViewFactory(component, styles, protoViews, changeDetectorFactories, componentViewFactory);
                    return viewFactory.createViewFactory(template, 0, []);
                }
                compileComponentCodeGen(component, template, styles, protoViews, changeDetectorFactoryExpressions, componentViewFactory) {
                    var viewFactory = new CodeGenViewFactory(component, styles, protoViews, changeDetectorFactoryExpressions, componentViewFactory);
                    var targetStatements = [];
                    var viewFactoryExpression = viewFactory.createViewFactory(template, 0, targetStatements);
                    return new source_module_1.SourceExpression(targetStatements.map(stmt => stmt.statement), viewFactoryExpression.expression);
                }
            };
            ViewCompiler = __decorate([
                di_1.Injectable(), 
                __metadata('design:paramtypes', [])
            ], ViewCompiler);
            exports_1("ViewCompiler", ViewCompiler);
            class CodeGenViewFactory {
                constructor(component, styles, protoViews, changeDetectorExpressions, componentViewFactory) {
                    this.component = component;
                    this.styles = styles;
                    this.protoViews = protoViews;
                    this.changeDetectorExpressions = changeDetectorExpressions;
                    this.componentViewFactory = componentViewFactory;
                    this._nextVarId = 0;
                }
                _nextVar(prefix) {
                    return `${prefix}${this._nextVarId++}_${this.component.type.name}`;
                }
                _nextRenderVar() { return this._nextVar('render'); }
                _nextAppVar() { return this._nextVar('app'); }
                _nextDisposableVar() {
                    return `disposable${this._nextVarId++}_${this.component.type.name}`;
                }
                createText(renderer, parent, text, targetStatements) {
                    var varName = this._nextRenderVar();
                    var statement = `var ${varName} = ${renderer.expression}.createText(${lang_1.isPresent(parent) ? parent.expression : null}, ${util_1.escapeSingleQuoteString(text)});`;
                    targetStatements.push(new util_1.Statement(statement));
                    return new util_1.Expression(varName);
                }
                createElement(renderer, parentRenderNode, name, rootSelector, targetStatements) {
                    var varName = this._nextRenderVar();
                    var valueExpr;
                    if (lang_1.isPresent(rootSelector)) {
                        valueExpr = `${rootSelector.expression} == null ?
        ${renderer.expression}.createElement(${lang_1.isPresent(parentRenderNode) ? parentRenderNode.expression : null}, ${util_1.escapeSingleQuoteString(name)}) :
        ${renderer.expression}.selectRootElement(${rootSelector.expression});`;
                    }
                    else {
                        valueExpr =
                            `${renderer.expression}.createElement(${lang_1.isPresent(parentRenderNode) ? parentRenderNode.expression : null}, ${util_1.escapeSingleQuoteString(name)})`;
                    }
                    var statement = `var ${varName} = ${valueExpr};`;
                    targetStatements.push(new util_1.Statement(statement));
                    return new util_1.Expression(varName);
                }
                createTemplateAnchor(renderer, parentRenderNode, targetStatements) {
                    var varName = this._nextRenderVar();
                    var valueExpr = `${renderer.expression}.createTemplateAnchor(${lang_1.isPresent(parentRenderNode) ? parentRenderNode.expression : null});`;
                    targetStatements.push(new util_1.Statement(`var ${varName} = ${valueExpr}`));
                    return new util_1.Expression(varName);
                }
                createGlobalEventListener(renderer, appView, boundElementIndex, eventAst, targetStatements) {
                    var disposableVar = this._nextDisposableVar();
                    var eventHandlerExpr = codeGenEventHandler(appView, boundElementIndex, eventAst.fullName);
                    targetStatements.push(new util_1.Statement(`var ${disposableVar} = ${renderer.expression}.listenGlobal(${util_1.escapeValue(eventAst.target)}, ${util_1.escapeValue(eventAst.name)}, ${eventHandlerExpr});`));
                    return new util_1.Expression(disposableVar);
                }
                createElementEventListener(renderer, appView, boundElementIndex, renderNode, eventAst, targetStatements) {
                    var disposableVar = this._nextDisposableVar();
                    var eventHandlerExpr = codeGenEventHandler(appView, boundElementIndex, eventAst.fullName);
                    targetStatements.push(new util_1.Statement(`var ${disposableVar} = ${renderer.expression}.listen(${renderNode.expression}, ${util_1.escapeValue(eventAst.name)}, ${eventHandlerExpr});`));
                    return new util_1.Expression(disposableVar);
                }
                setElementAttribute(renderer, renderNode, attrName, attrValue, targetStatements) {
                    targetStatements.push(new util_1.Statement(`${renderer.expression}.setElementAttribute(${renderNode.expression}, ${util_1.escapeSingleQuoteString(attrName)}, ${util_1.escapeSingleQuoteString(attrValue)});`));
                }
                createAppElement(appProtoEl, appView, renderNode, parentAppEl, embeddedViewFactory, targetStatements) {
                    var appVar = this._nextAppVar();
                    var varValue = `new ${proto_view_compiler_1.APP_EL_MODULE_REF}AppElement(${appProtoEl.expression}, ${appView.expression},
      ${lang_1.isPresent(parentAppEl) ? parentAppEl.expression : null}, ${renderNode.expression}, ${lang_1.isPresent(embeddedViewFactory) ? embeddedViewFactory.expression : null})`;
                    targetStatements.push(new util_1.Statement(`var ${appVar} = ${varValue};`));
                    return new util_1.Expression(appVar);
                }
                createAndSetComponentView(renderer, viewManager, view, appEl, component, contentNodesByNgContentIndex, targetStatements) {
                    var codeGenContentNodes;
                    if (this.component.type.isHost) {
                        codeGenContentNodes = `${view.expression}.projectableNodes`;
                    }
                    else {
                        codeGenContentNodes =
                            `[${contentNodesByNgContentIndex.map(nodes => util_1.codeGenFlatArray(nodes)).join(',')}]`;
                    }
                    targetStatements.push(new util_1.Statement(`${this.componentViewFactory(component)}(${renderer.expression}, ${viewManager.expression}, ${appEl.expression}, ${codeGenContentNodes}, null, null, null);`));
                }
                getProjectedNodes(projectableNodes, ngContentIndex) {
                    return new util_1.Expression(`${projectableNodes.expression}[${ngContentIndex}]`, true);
                }
                appendProjectedNodes(renderer, parent, nodes, targetStatements) {
                    targetStatements.push(new util_1.Statement(`${renderer.expression}.projectNodes(${parent.expression}, ${proto_view_compiler_1.APP_VIEW_MODULE_REF}flattenNestedViewRenderNodes(${nodes.expression}));`));
                }
                createViewFactory(asts, embeddedTemplateIndex, targetStatements) {
                    var compileProtoView = this.protoViews[embeddedTemplateIndex];
                    var isHostView = this.component.type.isHost;
                    var isComponentView = embeddedTemplateIndex === 0 && !isHostView;
                    var visitor = new ViewBuilderVisitor(new util_1.Expression('renderer'), new util_1.Expression('viewManager'), new util_1.Expression('projectableNodes'), isHostView ? new util_1.Expression('rootSelector') : null, new util_1.Expression('view'), compileProtoView, targetStatements, this);
                    template_ast_1.templateVisitAll(visitor, asts, new ParentElement(isComponentView ? new util_1.Expression('parentRenderNode') : null, null, null));
                    var appProtoView = compileProtoView.protoView.expression;
                    var viewFactoryName = codeGenViewFactoryName(this.component, embeddedTemplateIndex);
                    var changeDetectorFactory = this.changeDetectorExpressions.expressions[embeddedTemplateIndex];
                    var factoryArgs = [
                        'parentRenderer',
                        'viewManager',
                        'containerEl',
                        'projectableNodes',
                        'rootSelector',
                        'dynamicallyCreatedProviders',
                        'rootInjector'
                    ];
                    var initRendererStmts = [];
                    var rendererExpr = `parentRenderer`;
                    if (embeddedTemplateIndex === 0) {
                        var renderCompTypeVar = this._nextVar('renderType');
                        targetStatements.push(new util_1.Statement(`var ${renderCompTypeVar} = null;`));
                        var stylesVar = this._nextVar('styles');
                        targetStatements.push(new util_1.Statement(`${util_1.CONST_VAR} ${stylesVar} = ${this.styles.expression};`));
                        var encapsulation = this.component.template.encapsulation;
                        initRendererStmts.push(`if (${renderCompTypeVar} == null) {
        ${renderCompTypeVar} = viewManager.createRenderComponentType(${codeGenViewEncapsulation(encapsulation)}, ${stylesVar});
      }`);
                        rendererExpr = `parentRenderer.renderComponent(${renderCompTypeVar})`;
                    }
                    var statement = `
${util_1.codeGenFnHeader(factoryArgs, viewFactoryName)}{
  ${initRendererStmts.join('\n')}
  var renderer = ${rendererExpr};
  var view = new ${proto_view_compiler_1.APP_VIEW_MODULE_REF}AppView(
    ${appProtoView}, renderer, viewManager,
    projectableNodes,
    containerEl,
    dynamicallyCreatedProviders, rootInjector,
    ${changeDetectorFactory}()
  );
  ${proto_view_compiler_1.APP_VIEW_MODULE_REF}checkSlotCount(${util_1.escapeValue(this.component.type.name)}, ${this.component.template.ngContentSelectors.length}, projectableNodes);
  ${isComponentView ? 'var parentRenderNode = renderer.createViewRoot(view.containerAppElement.nativeElement);' : ''}
  ${visitor.renderStmts.map(stmt => stmt.statement).join('\n')}
  ${visitor.appStmts.map(stmt => stmt.statement).join('\n')}

  view.init(${util_1.codeGenFlatArray(visitor.rootNodesOrAppElements)}, ${util_1.codeGenArray(visitor.renderNodes)}, ${util_1.codeGenArray(visitor.appDisposables)},
            ${util_1.codeGenArray(visitor.appElements)});
  return view;
}`;
                    targetStatements.push(new util_1.Statement(statement));
                    return new util_1.Expression(viewFactoryName);
                }
            }
            class RuntimeViewFactory {
                constructor(component, styles, protoViews, changeDetectorFactories, componentViewFactory) {
                    this.component = component;
                    this.styles = styles;
                    this.protoViews = protoViews;
                    this.changeDetectorFactories = changeDetectorFactories;
                    this.componentViewFactory = componentViewFactory;
                }
                createText(renderer, parent, text, targetStatements) {
                    return renderer.createText(parent, text);
                }
                createElement(renderer, parent, name, rootSelector, targetStatements) {
                    var el;
                    if (lang_1.isPresent(rootSelector)) {
                        el = renderer.selectRootElement(rootSelector);
                    }
                    else {
                        el = renderer.createElement(parent, name);
                    }
                    return el;
                }
                createTemplateAnchor(renderer, parent, targetStatements) {
                    return renderer.createTemplateAnchor(parent);
                }
                createGlobalEventListener(renderer, appView, boundElementIndex, eventAst, targetStatements) {
                    return renderer.listenGlobal(eventAst.target, eventAst.name, (event) => appView.triggerEventHandlers(eventAst.fullName, event, boundElementIndex));
                }
                createElementEventListener(renderer, appView, boundElementIndex, renderNode, eventAst, targetStatements) {
                    return renderer.listen(renderNode, eventAst.name, (event) => appView.triggerEventHandlers(eventAst.fullName, event, boundElementIndex));
                }
                setElementAttribute(renderer, renderNode, attrName, attrValue, targetStatements) {
                    renderer.setElementAttribute(renderNode, attrName, attrValue);
                }
                createAppElement(appProtoEl, appView, renderNode, parentAppEl, embeddedViewFactory, targetStatements) {
                    return new element_1.AppElement(appProtoEl, appView, parentAppEl, renderNode, embeddedViewFactory);
                }
                createAndSetComponentView(renderer, viewManager, appView, appEl, component, contentNodesByNgContentIndex, targetStatements) {
                    var flattenedContentNodes;
                    if (this.component.type.isHost) {
                        flattenedContentNodes = appView.projectableNodes;
                    }
                    else {
                        flattenedContentNodes = collection_1.ListWrapper.createFixedSize(contentNodesByNgContentIndex.length);
                        for (var i = 0; i < contentNodesByNgContentIndex.length; i++) {
                            flattenedContentNodes[i] = util_1.flattenArray(contentNodesByNgContentIndex[i], []);
                        }
                    }
                    this.componentViewFactory(component)(renderer, viewManager, appEl, flattenedContentNodes);
                }
                getProjectedNodes(projectableNodes, ngContentIndex) {
                    return projectableNodes[ngContentIndex];
                }
                appendProjectedNodes(renderer, parent, nodes, targetStatements) {
                    renderer.projectNodes(parent, view_1.flattenNestedViewRenderNodes(nodes));
                }
                createViewFactory(asts, embeddedTemplateIndex, targetStatements) {
                    var compileProtoView = this.protoViews[embeddedTemplateIndex];
                    var isComponentView = compileProtoView.protoView.type === view_type_1.ViewType.COMPONENT;
                    var renderComponentType = null;
                    return (parentRenderer, viewManager, containerEl, projectableNodes, rootSelector = null, dynamicallyCreatedProviders = null, rootInjector = null) => {
                        view_1.checkSlotCount(this.component.type.name, this.component.template.ngContentSelectors.length, projectableNodes);
                        var renderer;
                        if (embeddedTemplateIndex === 0) {
                            if (lang_1.isBlank(renderComponentType)) {
                                renderComponentType = viewManager.createRenderComponentType(this.component.template.encapsulation, this.styles);
                            }
                            renderer = parentRenderer.renderComponent(renderComponentType);
                        }
                        else {
                            renderer = parentRenderer;
                        }
                        var changeDetector = this.changeDetectorFactories[embeddedTemplateIndex]();
                        var view = new view_1.AppView(compileProtoView.protoView, renderer, viewManager, projectableNodes, containerEl, dynamicallyCreatedProviders, rootInjector, changeDetector);
                        var visitor = new ViewBuilderVisitor(renderer, viewManager, projectableNodes, rootSelector, view, compileProtoView, [], this);
                        var parentRenderNode = isComponentView ? renderer.createViewRoot(containerEl.nativeElement) : null;
                        template_ast_1.templateVisitAll(visitor, asts, new ParentElement(parentRenderNode, null, null));
                        view.init(util_1.flattenArray(visitor.rootNodesOrAppElements, []), visitor.renderNodes, visitor.appDisposables, visitor.appElements);
                        return view;
                    };
                }
            }
            class ParentElement {
                constructor(renderNode, appEl, component) {
                    this.renderNode = renderNode;
                    this.appEl = appEl;
                    this.component = component;
                    if (lang_1.isPresent(component)) {
                        this.contentNodesByNgContentIndex =
                            collection_1.ListWrapper.createFixedSize(component.template.ngContentSelectors.length);
                        for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
                            this.contentNodesByNgContentIndex[i] = [];
                        }
                    }
                    else {
                        this.contentNodesByNgContentIndex = null;
                    }
                }
                addContentNode(ngContentIndex, nodeExpr) {
                    this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
                }
            }
            class ViewBuilderVisitor {
                constructor(renderer, viewManager, projectableNodes, rootSelector, view, protoView, targetStatements, factory) {
                    this.renderer = renderer;
                    this.viewManager = viewManager;
                    this.projectableNodes = projectableNodes;
                    this.rootSelector = rootSelector;
                    this.view = view;
                    this.protoView = protoView;
                    this.targetStatements = targetStatements;
                    this.factory = factory;
                    this.renderStmts = [];
                    this.renderNodes = [];
                    this.appStmts = [];
                    this.appElements = [];
                    this.appDisposables = [];
                    this.rootNodesOrAppElements = [];
                    this.elementCount = 0;
                }
                _addRenderNode(renderNode, appEl, ngContentIndex, parent) {
                    this.renderNodes.push(renderNode);
                    if (lang_1.isPresent(parent.component)) {
                        if (lang_1.isPresent(ngContentIndex)) {
                            parent.addContentNode(ngContentIndex, lang_1.isPresent(appEl) ? appEl : renderNode);
                        }
                    }
                    else if (lang_1.isBlank(parent.renderNode)) {
                        this.rootNodesOrAppElements.push(lang_1.isPresent(appEl) ? appEl : renderNode);
                    }
                }
                _getParentRenderNode(ngContentIndex, parent) {
                    return lang_1.isPresent(parent.component) &&
                        parent.component.template.encapsulation !== view_2.ViewEncapsulation.Native ?
                        null :
                        parent.renderNode;
                }
                visitBoundText(ast, parent) {
                    return this._visitText('', ast.ngContentIndex, parent);
                }
                visitText(ast, parent) {
                    return this._visitText(ast.value, ast.ngContentIndex, parent);
                }
                _visitText(value, ngContentIndex, parent) {
                    var renderNode = this.factory.createText(this.renderer, this._getParentRenderNode(ngContentIndex, parent), value, this.renderStmts);
                    this._addRenderNode(renderNode, null, ngContentIndex, parent);
                    return null;
                }
                visitNgContent(ast, parent) {
                    var nodesExpression = this.factory.getProjectedNodes(this.projectableNodes, ast.index);
                    if (lang_1.isPresent(parent.component)) {
                        if (lang_1.isPresent(ast.ngContentIndex)) {
                            parent.addContentNode(ast.ngContentIndex, nodesExpression);
                        }
                    }
                    else {
                        if (lang_1.isPresent(parent.renderNode)) {
                            this.factory.appendProjectedNodes(this.renderer, parent.renderNode, nodesExpression, this.renderStmts);
                        }
                        else {
                            this.rootNodesOrAppElements.push(nodesExpression);
                        }
                    }
                    return null;
                }
                visitElement(ast, parent) {
                    var renderNode = this.factory.createElement(this.renderer, this._getParentRenderNode(ast.ngContentIndex, parent), ast.name, this.rootSelector, this.renderStmts);
                    var component = ast.getComponent();
                    var elementIndex = this.elementCount++;
                    var protoEl = this.protoView.protoElements[elementIndex];
                    protoEl.renderEvents.forEach((eventAst) => {
                        var disposable;
                        if (lang_1.isPresent(eventAst.target)) {
                            disposable = this.factory.createGlobalEventListener(this.renderer, this.view, protoEl.boundElementIndex, eventAst, this.renderStmts);
                        }
                        else {
                            disposable = this.factory.createElementEventListener(this.renderer, this.view, protoEl.boundElementIndex, renderNode, eventAst, this.renderStmts);
                        }
                        this.appDisposables.push(disposable);
                    });
                    for (var i = 0; i < protoEl.attrNameAndValues.length; i++) {
                        var attrName = protoEl.attrNameAndValues[i][0];
                        var attrValue = protoEl.attrNameAndValues[i][1];
                        this.factory.setElementAttribute(this.renderer, renderNode, attrName, attrValue, this.renderStmts);
                    }
                    var appEl = null;
                    if (lang_1.isPresent(protoEl.appProtoEl)) {
                        appEl = this.factory.createAppElement(protoEl.appProtoEl, this.view, renderNode, parent.appEl, null, this.appStmts);
                        this.appElements.push(appEl);
                    }
                    this._addRenderNode(renderNode, appEl, ast.ngContentIndex, parent);
                    var newParent = new ParentElement(renderNode, lang_1.isPresent(appEl) ? appEl : parent.appEl, component);
                    template_ast_1.templateVisitAll(this, ast.children, newParent);
                    if (lang_1.isPresent(appEl) && lang_1.isPresent(component)) {
                        this.factory.createAndSetComponentView(this.renderer, this.viewManager, this.view, appEl, component, newParent.contentNodesByNgContentIndex, this.appStmts);
                    }
                    return null;
                }
                visitEmbeddedTemplate(ast, parent) {
                    var renderNode = this.factory.createTemplateAnchor(this.renderer, this._getParentRenderNode(ast.ngContentIndex, parent), this.renderStmts);
                    var elementIndex = this.elementCount++;
                    var protoEl = this.protoView.protoElements[elementIndex];
                    var embeddedViewFactory = this.factory.createViewFactory(ast.children, protoEl.embeddedTemplateIndex, this.targetStatements);
                    var appEl = this.factory.createAppElement(protoEl.appProtoEl, this.view, renderNode, parent.appEl, embeddedViewFactory, this.appStmts);
                    this._addRenderNode(renderNode, appEl, ast.ngContentIndex, parent);
                    this.appElements.push(appEl);
                    return null;
                }
                visitVariable(ast, ctx) { return null; }
                visitAttr(ast, ctx) { return null; }
                visitDirective(ast, ctx) { return null; }
                visitEvent(ast, ctx) { return null; }
                visitDirectiveProperty(ast, context) { return null; }
                visitElementProperty(ast, context) { return null; }
            }
        }
    }
});
//# sourceMappingURL=view_compiler.js.map
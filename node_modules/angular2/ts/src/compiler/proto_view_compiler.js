System.register(['angular2/src/facade/lang', 'angular2/src/facade/collection', './template_ast', './source_module', 'angular2/src/core/linker/view', 'angular2/src/core/linker/view_type', 'angular2/src/core/linker/element', './util', 'angular2/src/core/di'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var lang_1, collection_1, template_ast_1, source_module_1, view_1, view_type_1, element_1, util_1, di_1;
    var PROTO_VIEW_JIT_IMPORTS, APP_VIEW_MODULE_REF, VIEW_TYPE_MODULE_REF, APP_EL_MODULE_REF, METADATA_MODULE_REF, IMPLICIT_TEMPLATE_VAR, CLASS_ATTR, STYLE_ATTR, ProtoViewCompiler, CompileProtoViews, CompileProtoView, CompileProtoElement, ProtoViewFactory, CodeGenProtoViewFactory, RuntimeProtoViewFactory, ProtoViewBuilderVisitor, DirectiveContext;
    function visitAndReturnContext(visitor, asts, context) {
        template_ast_1.templateVisitAll(visitor, asts, context);
        return context;
    }
    function mapToKeyValueArray(data) {
        var entryArray = [];
        collection_1.StringMapWrapper.forEach(data, (value, name) => { entryArray.push([name, value]); });
        // We need to sort to get a defined output order
        // for tests and for caching generated artifacts...
        collection_1.ListWrapper.sort(entryArray, (entry1, entry2) => lang_1.StringWrapper.compare(entry1[0], entry2[0]));
        var keyValueArray = [];
        entryArray.forEach((entry) => { keyValueArray.push([entry[0], entry[1]]); });
        return keyValueArray;
    }
    function mergeAttributeValue(attrName, attrValue1, attrValue2) {
        if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
            return `${attrValue1} ${attrValue2}`;
        }
        else {
            return attrValue2;
        }
    }
    function keyValueArrayToStringMap(keyValueArray) {
        var stringMap = {};
        for (var i = 0; i < keyValueArray.length; i++) {
            var entry = keyValueArray[i];
            stringMap[entry[0]] = entry[1];
        }
        return stringMap;
    }
    function codeGenDirectivesArray(directives) {
        var expressions = directives.map(directiveType => typeRef(directiveType.type));
        return `[${expressions.join(',')}]`;
    }
    function codeGenTypesArray(types) {
        var expressions = types.map(typeRef);
        return `[${expressions.join(',')}]`;
    }
    function codeGenViewType(value) {
        if (lang_1.IS_DART) {
            return `${VIEW_TYPE_MODULE_REF}${value}`;
        }
        else {
            return `${value}`;
        }
    }
    function typeRef(type) {
        return `${source_module_1.moduleRef(type.moduleUrl)}${type.name}`;
    }
    function getViewType(component, embeddedTemplateIndex) {
        if (embeddedTemplateIndex > 0) {
            return view_type_1.ViewType.EMBEDDED;
        }
        else if (component.type.isHost) {
            return view_type_1.ViewType.HOST;
        }
        else {
            return view_type_1.ViewType.COMPONENT;
        }
    }
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (template_ast_1_1) {
                template_ast_1 = template_ast_1_1;
            },
            function (source_module_1_1) {
                source_module_1 = source_module_1_1;
            },
            function (view_1_1) {
                view_1 = view_1_1;
            },
            function (view_type_1_1) {
                view_type_1 = view_type_1_1;
            },
            function (element_1_1) {
                element_1 = element_1_1;
            },
            function (util_1_1) {
                util_1 = util_1_1;
            },
            function (di_1_1) {
                di_1 = di_1_1;
            }],
        execute: function() {
            exports_1("PROTO_VIEW_JIT_IMPORTS", PROTO_VIEW_JIT_IMPORTS = lang_1.CONST_EXPR({ 'AppProtoView': view_1.AppProtoView, 'AppProtoElement': element_1.AppProtoElement, 'ViewType': view_type_1.ViewType }));
            // TODO: have a single file that reexports everything needed for
            // codegen explicitly
            // - helps understanding what codegen works against
            // - less imports in codegen code
            exports_1("APP_VIEW_MODULE_REF", APP_VIEW_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/view' + util_1.MODULE_SUFFIX));
            exports_1("VIEW_TYPE_MODULE_REF", VIEW_TYPE_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/view_type' + util_1.MODULE_SUFFIX));
            exports_1("APP_EL_MODULE_REF", APP_EL_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/element' + util_1.MODULE_SUFFIX));
            exports_1("METADATA_MODULE_REF", METADATA_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/metadata/view' + util_1.MODULE_SUFFIX));
            IMPLICIT_TEMPLATE_VAR = '\$implicit';
            CLASS_ATTR = 'class';
            STYLE_ATTR = 'style';
            let ProtoViewCompiler = class ProtoViewCompiler {
                constructor() {
                }
                compileProtoViewRuntime(metadataCache, component, template, pipes) {
                    var protoViewFactory = new RuntimeProtoViewFactory(metadataCache, component, pipes);
                    var allProtoViews = [];
                    protoViewFactory.createCompileProtoView(template, [], [], allProtoViews);
                    return new CompileProtoViews([], allProtoViews);
                }
                compileProtoViewCodeGen(resolvedMetadataCacheExpr, component, template, pipes) {
                    var protoViewFactory = new CodeGenProtoViewFactory(resolvedMetadataCacheExpr, component, pipes);
                    var allProtoViews = [];
                    var allStatements = [];
                    protoViewFactory.createCompileProtoView(template, [], allStatements, allProtoViews);
                    return new CompileProtoViews(allStatements.map(stmt => stmt.statement), allProtoViews);
                }
            };
            ProtoViewCompiler = __decorate([
                di_1.Injectable(), 
                __metadata('design:paramtypes', [])
            ], ProtoViewCompiler);
            exports_1("ProtoViewCompiler", ProtoViewCompiler);
            class CompileProtoViews {
                constructor(declarations, protoViews) {
                    this.declarations = declarations;
                    this.protoViews = protoViews;
                }
            }
            exports_1("CompileProtoViews", CompileProtoViews);
            class CompileProtoView {
                constructor(embeddedTemplateIndex, protoElements, protoView) {
                    this.embeddedTemplateIndex = embeddedTemplateIndex;
                    this.protoElements = protoElements;
                    this.protoView = protoView;
                }
            }
            exports_1("CompileProtoView", CompileProtoView);
            class CompileProtoElement {
                constructor(boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives, embeddedTemplateIndex, appProtoEl) {
                    this.boundElementIndex = boundElementIndex;
                    this.attrNameAndValues = attrNameAndValues;
                    this.variableNameAndValues = variableNameAndValues;
                    this.renderEvents = renderEvents;
                    this.directives = directives;
                    this.embeddedTemplateIndex = embeddedTemplateIndex;
                    this.appProtoEl = appProtoEl;
                }
            }
            exports_1("CompileProtoElement", CompileProtoElement);
            class ProtoViewFactory {
                constructor(component) {
                    this.component = component;
                }
                createCompileProtoView(template, templateVariableBindings, targetStatements, targetProtoViews) {
                    var embeddedTemplateIndex = targetProtoViews.length;
                    // Note: targetProtoViews needs to be in depth first order.
                    // So we "reserve" a space here that we fill after the recursion is done
                    targetProtoViews.push(null);
                    var builder = new ProtoViewBuilderVisitor(this, targetStatements, targetProtoViews);
                    template_ast_1.templateVisitAll(builder, template);
                    var viewType = getViewType(this.component, embeddedTemplateIndex);
                    var appProtoView = this.createAppProtoView(embeddedTemplateIndex, viewType, templateVariableBindings, targetStatements);
                    var cpv = new CompileProtoView(embeddedTemplateIndex, builder.protoElements, appProtoView);
                    targetProtoViews[embeddedTemplateIndex] = cpv;
                    return cpv;
                }
            }
            class CodeGenProtoViewFactory extends ProtoViewFactory {
                constructor(resolvedMetadataCacheExpr, component, pipes) {
                    super(component);
                    this.resolvedMetadataCacheExpr = resolvedMetadataCacheExpr;
                    this.pipes = pipes;
                    this._nextVarId = 0;
                }
                _nextProtoViewVar(embeddedTemplateIndex) {
                    return `appProtoView${this._nextVarId++}_${this.component.type.name}${embeddedTemplateIndex}`;
                }
                createAppProtoView(embeddedTemplateIndex, viewType, templateVariableBindings, targetStatements) {
                    var protoViewVarName = this._nextProtoViewVar(embeddedTemplateIndex);
                    var viewTypeExpr = codeGenViewType(viewType);
                    var pipesExpr = embeddedTemplateIndex === 0 ?
                        codeGenTypesArray(this.pipes.map(pipeMeta => pipeMeta.type)) :
                        null;
                    var statement = `var ${protoViewVarName} = ${APP_VIEW_MODULE_REF}AppProtoView.create(${this.resolvedMetadataCacheExpr.expression}, ${viewTypeExpr}, ${pipesExpr}, ${util_1.codeGenStringMap(templateVariableBindings)});`;
                    targetStatements.push(new util_1.Statement(statement));
                    return new util_1.Expression(protoViewVarName);
                }
                createAppProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, directives, targetStatements) {
                    var varName = `appProtoEl${this._nextVarId++}_${this.component.type.name}`;
                    var value = `${APP_EL_MODULE_REF}AppProtoElement.create(
        ${this.resolvedMetadataCacheExpr.expression},
        ${boundElementIndex},
        ${util_1.codeGenStringMap(attrNameAndValues)},
        ${codeGenDirectivesArray(directives)},
        ${util_1.codeGenStringMap(variableNameAndValues)}
      )`;
                    var statement = `var ${varName} = ${value};`;
                    targetStatements.push(new util_1.Statement(statement));
                    return new util_1.Expression(varName);
                }
            }
            class RuntimeProtoViewFactory extends ProtoViewFactory {
                constructor(metadataCache, component, pipes) {
                    super(component);
                    this.metadataCache = metadataCache;
                    this.pipes = pipes;
                }
                createAppProtoView(embeddedTemplateIndex, viewType, templateVariableBindings, targetStatements) {
                    var pipes = embeddedTemplateIndex === 0 ? this.pipes.map(pipeMeta => pipeMeta.type.runtime) : [];
                    var templateVars = keyValueArrayToStringMap(templateVariableBindings);
                    return view_1.AppProtoView.create(this.metadataCache, viewType, pipes, templateVars);
                }
                createAppProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, directives, targetStatements) {
                    var attrs = keyValueArrayToStringMap(attrNameAndValues);
                    return element_1.AppProtoElement.create(this.metadataCache, boundElementIndex, attrs, directives.map(dirMeta => dirMeta.type.runtime), keyValueArrayToStringMap(variableNameAndValues));
                }
            }
            class ProtoViewBuilderVisitor {
                constructor(factory, allStatements, allProtoViews) {
                    this.factory = factory;
                    this.allStatements = allStatements;
                    this.allProtoViews = allProtoViews;
                    this.protoElements = [];
                    this.boundElementCount = 0;
                }
                _readAttrNameAndValues(directives, attrAsts) {
                    var attrs = visitAndReturnContext(this, attrAsts, {});
                    directives.forEach(directiveMeta => {
                        collection_1.StringMapWrapper.forEach(directiveMeta.hostAttributes, (value, name) => {
                            var prevValue = attrs[name];
                            attrs[name] = lang_1.isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
                        });
                    });
                    return mapToKeyValueArray(attrs);
                }
                visitBoundText(ast, context) { return null; }
                visitText(ast, context) { return null; }
                visitNgContent(ast, context) { return null; }
                visitElement(ast, context) {
                    var boundElementIndex = null;
                    if (ast.isBound()) {
                        boundElementIndex = this.boundElementCount++;
                    }
                    var component = ast.getComponent();
                    var variableNameAndValues = [];
                    if (lang_1.isBlank(component)) {
                        ast.exportAsVars.forEach((varAst) => { variableNameAndValues.push([varAst.name, null]); });
                    }
                    var directives = [];
                    var renderEvents = visitAndReturnContext(this, ast.outputs, new Map());
                    collection_1.ListWrapper.forEachWithIndex(ast.directives, (directiveAst, index) => {
                        directiveAst.visit(this, new DirectiveContext(index, boundElementIndex, renderEvents, variableNameAndValues, directives));
                    });
                    var renderEventArray = [];
                    renderEvents.forEach((eventAst, _) => renderEventArray.push(eventAst));
                    var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
                    this._addProtoElement(ast.isBound(), boundElementIndex, attrNameAndValues, variableNameAndValues, renderEventArray, directives, null);
                    template_ast_1.templateVisitAll(this, ast.children);
                    return null;
                }
                visitEmbeddedTemplate(ast, context) {
                    var boundElementIndex = this.boundElementCount++;
                    var directives = [];
                    collection_1.ListWrapper.forEachWithIndex(ast.directives, (directiveAst, index) => {
                        directiveAst.visit(this, new DirectiveContext(index, boundElementIndex, new Map(), [], directives));
                    });
                    var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
                    var templateVariableBindings = ast.vars.map(varAst => [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]);
                    var nestedProtoView = this.factory.createCompileProtoView(ast.children, templateVariableBindings, this.allStatements, this.allProtoViews);
                    this._addProtoElement(true, boundElementIndex, attrNameAndValues, [], [], directives, nestedProtoView.embeddedTemplateIndex);
                    return null;
                }
                _addProtoElement(isBound, boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives, embeddedTemplateIndex) {
                    var appProtoEl = null;
                    if (isBound) {
                        appProtoEl =
                            this.factory.createAppProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, directives, this.allStatements);
                    }
                    var compileProtoEl = new CompileProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives, embeddedTemplateIndex, appProtoEl);
                    this.protoElements.push(compileProtoEl);
                }
                visitVariable(ast, ctx) { return null; }
                visitAttr(ast, attrNameAndValues) {
                    attrNameAndValues[ast.name] = ast.value;
                    return null;
                }
                visitDirective(ast, ctx) {
                    ctx.targetDirectives.push(ast.directive);
                    template_ast_1.templateVisitAll(this, ast.hostEvents, ctx.hostEventTargetAndNames);
                    ast.exportAsVars.forEach(varAst => { ctx.targetVariableNameAndValues.push([varAst.name, ctx.index]); });
                    return null;
                }
                visitEvent(ast, eventTargetAndNames) {
                    eventTargetAndNames.set(ast.fullName, ast);
                    return null;
                }
                visitDirectiveProperty(ast, context) { return null; }
                visitElementProperty(ast, context) { return null; }
            }
            class DirectiveContext {
                constructor(index, boundElementIndex, hostEventTargetAndNames, targetVariableNameAndValues, targetDirectives) {
                    this.index = index;
                    this.boundElementIndex = boundElementIndex;
                    this.hostEventTargetAndNames = hostEventTargetAndNames;
                    this.targetVariableNameAndValues = targetVariableNameAndValues;
                    this.targetDirectives = targetDirectives;
                }
            }
        }
    }
});
//# sourceMappingURL=proto_view_compiler.js.map
System.register([], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var globalScope, IS_DART, _global, Type, Math, Date, _devMode, _modeLocked, StringWrapper, StringJoiner, NumberParseError, NumberWrapper, RegExp, RegExpWrapper, RegExpMatcherWrapper, FunctionWrapper, Json, DateWrapper, _symbolIterator;
    function getTypeNameForDebugging(type) {
        return type['name'];
    }
    exports_1("getTypeNameForDebugging", getTypeNameForDebugging);
    function lockMode() {
        _modeLocked = true;
    }
    exports_1("lockMode", lockMode);
    /**
     * Disable Angular's development mode, which turns off assertions and other
     * checks within the framework.
     *
     * One important assertion this disables verifies that a change detection pass
     * does not result in additional changes to any bindings (also known as
     * unidirectional data flow).
     */
    function enableProdMode() {
        if (_modeLocked) {
            // Cannot use BaseException as that ends up importing from facade/lang.
            throw 'Cannot enable prod mode after platform setup.';
        }
        _devMode = false;
    }
    exports_1("enableProdMode", enableProdMode);
    function assertionsEnabled() {
        return _devMode;
    }
    exports_1("assertionsEnabled", assertionsEnabled);
    // This function is needed only to properly support Dart's const expressions
    // see https://github.com/angular/ts2dart/pull/151 for more info
    function CONST_EXPR(expr) {
        return expr;
    }
    exports_1("CONST_EXPR", CONST_EXPR);
    function CONST() {
        return (target) => target;
    }
    exports_1("CONST", CONST);
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    exports_1("isPresent", isPresent);
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    exports_1("isBlank", isBlank);
    function isString(obj) {
        return typeof obj === "string";
    }
    exports_1("isString", isString);
    function isFunction(obj) {
        return typeof obj === "function";
    }
    exports_1("isFunction", isFunction);
    function isType(obj) {
        return isFunction(obj);
    }
    exports_1("isType", isType);
    function isStringMap(obj) {
        return typeof obj === 'object' && obj !== null;
    }
    exports_1("isStringMap", isStringMap);
    function isPromise(obj) {
        return obj instanceof _global.Promise;
    }
    exports_1("isPromise", isPromise);
    function isArray(obj) {
        return Array.isArray(obj);
    }
    exports_1("isArray", isArray);
    function isNumber(obj) {
        return typeof obj === 'number';
    }
    exports_1("isNumber", isNumber);
    function isDate(obj) {
        return obj instanceof Date && !isNaN(obj.valueOf());
    }
    exports_1("isDate", isDate);
    function noop() { }
    exports_1("noop", noop);
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.name) {
            return token.name;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf("\n");
        return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
    }
    exports_1("stringify", stringify);
    // serialize / deserialize enum exist only for consistency with dart API
    // enums in typescript don't need to be serialized
    function serializeEnum(val) {
        return val;
    }
    exports_1("serializeEnum", serializeEnum);
    function deserializeEnum(val, values) {
        return val;
    }
    exports_1("deserializeEnum", deserializeEnum);
    // JS has NaN !== NaN
    function looseIdentical(a, b) {
        return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
    }
    exports_1("looseIdentical", looseIdentical);
    // JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
    function getMapKey(value) {
        return value;
    }
    exports_1("getMapKey", getMapKey);
    function normalizeBlank(obj) {
        return isBlank(obj) ? null : obj;
    }
    exports_1("normalizeBlank", normalizeBlank);
    function normalizeBool(obj) {
        return isBlank(obj) ? false : obj;
    }
    exports_1("normalizeBool", normalizeBool);
    function isJsObject(o) {
        return o !== null && (typeof o === "function" || typeof o === "object");
    }
    exports_1("isJsObject", isJsObject);
    function print(obj) {
        console.log(obj);
    }
    exports_1("print", print);
    function setValueOnPath(global, path, value) {
        var parts = path.split('.');
        var obj = global;
        while (parts.length > 1) {
            var name = parts.shift();
            if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
                obj = obj[name];
            }
            else {
                obj = obj[name] = {};
            }
        }
        if (obj === undefined || obj === null) {
            obj = {};
        }
        obj[parts.shift()] = value;
    }
    exports_1("setValueOnPath", setValueOnPath);
    function getSymbolIterator() {
        if (isBlank(_symbolIterator)) {
            if (isPresent(Symbol) && isPresent(Symbol.iterator)) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                var keys = Object.getOwnPropertyNames(Map.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        Map.prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }
    exports_1("getSymbolIterator", getSymbolIterator);
    function evalExpression(sourceUrl, expr, declarations, vars) {
        var fnBody = `${declarations}\nreturn ${expr}\n//# sourceURL=${sourceUrl}`;
        var fnArgNames = [];
        var fnArgValues = [];
        for (var argName in vars) {
            fnArgNames.push(argName);
            fnArgValues.push(vars[argName]);
        }
        return new Function(...fnArgNames.concat(fnBody))(...fnArgValues);
    }
    exports_1("evalExpression", evalExpression);
    function isPrimitive(obj) {
        return !isJsObject(obj);
    }
    exports_1("isPrimitive", isPrimitive);
    function hasConstructor(value, type) {
        return value.constructor === type;
    }
    exports_1("hasConstructor", hasConstructor);
    return {
        setters:[],
        execute: function() {
            if (typeof window === 'undefined') {
                if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
                    // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
                    globalScope = self;
                }
                else {
                    globalScope = global;
                }
            }
            else {
                globalScope = window;
            }
            exports_1("IS_DART", IS_DART = false);
            // Need to declare a new variable for global here since TypeScript
            // exports the original value of the symbol.
            _global = globalScope;
            exports_1("global", _global);
            exports_1("Type", Type = Function);
            exports_1("Math", Math = _global.Math);
            exports_1("Date", Date = _global.Date);
            _devMode = true;
            _modeLocked = false;
            // TODO: remove calls to assert in production environment
            // Note: Can't just export this and import in in other files
            // as `assert` is a reserved keyword in Dart
            _global.assert = function assert(condition) {
                // TODO: to be fixed properly via #2830, noop for now
            };
            class StringWrapper {
                static fromCharCode(code) { return String.fromCharCode(code); }
                static charCodeAt(s, index) { return s.charCodeAt(index); }
                static split(s, regExp) { return s.split(regExp); }
                static equals(s, s2) { return s === s2; }
                static stripLeft(s, charVal) {
                    if (s && s.length) {
                        var pos = 0;
                        for (var i = 0; i < s.length; i++) {
                            if (s[i] != charVal)
                                break;
                            pos++;
                        }
                        s = s.substring(pos);
                    }
                    return s;
                }
                static stripRight(s, charVal) {
                    if (s && s.length) {
                        var pos = s.length;
                        for (var i = s.length - 1; i >= 0; i--) {
                            if (s[i] != charVal)
                                break;
                            pos--;
                        }
                        s = s.substring(0, pos);
                    }
                    return s;
                }
                static replace(s, from, replace) {
                    return s.replace(from, replace);
                }
                static replaceAll(s, from, replace) {
                    return s.replace(from, replace);
                }
                static slice(s, from = 0, to = null) {
                    return s.slice(from, to === null ? undefined : to);
                }
                static replaceAllMapped(s, from, cb) {
                    return s.replace(from, function (...matches) {
                        // Remove offset & string from the result array
                        matches.splice(-2, 2);
                        // The callback receives match, p1, ..., pn
                        return cb(matches);
                    });
                }
                static contains(s, substr) { return s.indexOf(substr) != -1; }
                static compare(a, b) {
                    if (a < b) {
                        return -1;
                    }
                    else if (a > b) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            }
            exports_1("StringWrapper", StringWrapper);
            class StringJoiner {
                constructor(parts = []) {
                    this.parts = parts;
                }
                add(part) { this.parts.push(part); }
                toString() { return this.parts.join(""); }
            }
            exports_1("StringJoiner", StringJoiner);
            class NumberParseError extends Error {
                constructor(message) {
                    super();
                    this.message = message;
                }
                toString() { return this.message; }
            }
            exports_1("NumberParseError", NumberParseError);
            class NumberWrapper {
                static toFixed(n, fractionDigits) { return n.toFixed(fractionDigits); }
                static equal(a, b) { return a === b; }
                static parseIntAutoRadix(text) {
                    var result = parseInt(text);
                    if (isNaN(result)) {
                        throw new NumberParseError("Invalid integer literal when parsing " + text);
                    }
                    return result;
                }
                static parseInt(text, radix) {
                    if (radix == 10) {
                        if (/^(\-|\+)?[0-9]+$/.test(text)) {
                            return parseInt(text, radix);
                        }
                    }
                    else if (radix == 16) {
                        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                            return parseInt(text, radix);
                        }
                    }
                    else {
                        var result = parseInt(text, radix);
                        if (!isNaN(result)) {
                            return result;
                        }
                    }
                    throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
                        radix);
                }
                // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
                static parseFloat(text) { return parseFloat(text); }
                static get NaN() { return NaN; }
                static isNaN(value) { return isNaN(value); }
                static isInteger(value) { return Number.isInteger(value); }
            }
            exports_1("NumberWrapper", NumberWrapper);
            exports_1("RegExp", RegExp = _global.RegExp);
            class RegExpWrapper {
                static create(regExpStr, flags = '') {
                    flags = flags.replace(/g/g, '');
                    return new _global.RegExp(regExpStr, flags + 'g');
                }
                static firstMatch(regExp, input) {
                    // Reset multimatch regex state
                    regExp.lastIndex = 0;
                    return regExp.exec(input);
                }
                static test(regExp, input) {
                    regExp.lastIndex = 0;
                    return regExp.test(input);
                }
                static matcher(regExp, input) {
                    // Reset regex state for the case
                    // someone did not loop over all matches
                    // last time.
                    regExp.lastIndex = 0;
                    return { re: regExp, input: input };
                }
            }
            exports_1("RegExpWrapper", RegExpWrapper);
            class RegExpMatcherWrapper {
                static next(matcher) {
                    return matcher.re.exec(matcher.input);
                }
            }
            exports_1("RegExpMatcherWrapper", RegExpMatcherWrapper);
            class FunctionWrapper {
                static apply(fn, posArgs) { return fn.apply(null, posArgs); }
            }
            exports_1("FunctionWrapper", FunctionWrapper);
            // Can't be all uppercase as our transpiler would think it is a special directive...
            class Json {
                static parse(s) { return _global.JSON.parse(s); }
                static stringify(data) {
                    // Dart doesn't take 3 arguments
                    return _global.JSON.stringify(data, null, 2);
                }
            }
            exports_1("Json", Json);
            class DateWrapper {
                static create(year, month = 1, day = 1, hour = 0, minutes = 0, seconds = 0, milliseconds = 0) {
                    return new Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
                }
                static fromISOString(str) { return new Date(str); }
                static fromMillis(ms) { return new Date(ms); }
                static toMillis(date) { return date.getTime(); }
                static now() { return new Date(); }
                static toJson(date) { return date.toJSON(); }
            }
            exports_1("DateWrapper", DateWrapper);
            _symbolIterator = null;
        }
    }
});
//# sourceMappingURL=lang.js.map
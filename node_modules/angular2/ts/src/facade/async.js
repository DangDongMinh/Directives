System.register(['angular2/src/facade/lang', 'angular2/src/facade/promise', 'rxjs/Subject', 'rxjs/observable/PromiseObservable', 'rxjs/operator/toPromise', 'rxjs/Observable'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var lang_1, Subject_1, PromiseObservable_1, toPromise_1;
    var TimerWrapper, ObservableWrapper, EventEmitter;
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (promise_1_1) {
                exports_1({
                    "PromiseWrapper": promise_1_1["PromiseWrapper"],
                    "PromiseCompleter": promise_1_1["PromiseCompleter"]
                });
            },
            function (Subject_1_1) {
                Subject_1 = Subject_1_1;
                exports_1({
                    "Subject": Subject_1_1["Subject"]
                });
            },
            function (PromiseObservable_1_1) {
                PromiseObservable_1 = PromiseObservable_1_1;
            },
            function (toPromise_1_1) {
                toPromise_1 = toPromise_1_1;
            },
            function (Observable_1_1) {
                exports_1({
                    "Observable": Observable_1_1["Observable"]
                });
            }],
        execute: function() {
            class TimerWrapper {
                static setTimeout(fn, millis) {
                    return lang_1.global.setTimeout(fn, millis);
                }
                static clearTimeout(id) { lang_1.global.clearTimeout(id); }
                static setInterval(fn, millis) {
                    return lang_1.global.setInterval(fn, millis);
                }
                static clearInterval(id) { lang_1.global.clearInterval(id); }
            }
            exports_1("TimerWrapper", TimerWrapper);
            class ObservableWrapper {
                // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
                static subscribe(emitter, onNext, onError, onComplete = () => { }) {
                    onError = (typeof onError === "function") && onError || lang_1.noop;
                    onComplete = (typeof onComplete === "function") && onComplete || lang_1.noop;
                    return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
                }
                static isObservable(obs) { return !!obs.subscribe; }
                /**
                 * Returns whether `obs` has any subscribers listening to events.
                 */
                static hasSubscribers(obs) { return obs.observers.length > 0; }
                static dispose(subscription) { subscription.unsubscribe(); }
                /**
                 * @deprecated - use callEmit() instead
                 */
                static callNext(emitter, value) { emitter.next(value); }
                static callEmit(emitter, value) { emitter.emit(value); }
                static callError(emitter, error) { emitter.error(error); }
                static callComplete(emitter) { emitter.complete(); }
                static fromPromise(promise) {
                    return PromiseObservable_1.PromiseObservable.create(promise);
                }
                static toPromise(obj) { return toPromise_1.toPromise.call(obj); }
            }
            exports_1("ObservableWrapper", ObservableWrapper);
            /**
             * Use by directives and components to emit custom Events.
             *
             * ### Examples
             *
             * In the following example, `Zippy` alternatively emits `open` and `close` events when its
             * title gets clicked:
             *
             * ```
             * @Component({
             *   selector: 'zippy',
             *   template: `
             *   <div class="zippy">
             *     <div (click)="toggle()">Toggle</div>
             *     <div [hidden]="!visible">
             *       <ng-content></ng-content>
             *     </div>
             *  </div>`})
             * export class Zippy {
             *   visible: boolean = true;
             *   @Output() open: EventEmitter<any> = new EventEmitter();
             *   @Output() close: EventEmitter<any> = new EventEmitter();
             *
             *   toggle() {
             *     this.visible = !this.visible;
             *     if (this.visible) {
             *       this.open.emit(null);
             *     } else {
             *       this.close.emit(null);
             *     }
             *   }
             * }
             * ```
             *
             * Use Rx.Observable but provides an adapter to make it work as specified here:
             * https://github.com/jhusain/observable-spec
             *
             * Once a reference implementation of the spec is available, switch to it.
             */
            class EventEmitter extends Subject_1.Subject {
                /**
                 * Creates an instance of [EventEmitter], which depending on [isAsync],
                 * delivers events synchronously or asynchronously.
                 */
                constructor(isAsync = true) {
                    super();
                    this._isAsync = isAsync;
                }
                emit(value) { super.next(value); }
                /**
                 * @deprecated - use .emit(value) instead
                 */
                next(value) { super.next(value); }
                subscribe(generatorOrNext, error, complete) {
                    let schedulerFn;
                    let errorFn = (err) => null;
                    let completeFn = () => null;
                    if (generatorOrNext && typeof generatorOrNext === 'object') {
                        schedulerFn = this._isAsync ? (value) => { setTimeout(() => generatorOrNext.next(value)); } :
                                (value) => { generatorOrNext.next(value); };
                        if (generatorOrNext.error) {
                            errorFn = this._isAsync ? (err) => { setTimeout(() => generatorOrNext.error(err)); } :
                                    (err) => { generatorOrNext.error(err); };
                        }
                        if (generatorOrNext.complete) {
                            completeFn = this._isAsync ? () => { setTimeout(() => generatorOrNext.complete()); } :
                                    () => { generatorOrNext.complete(); };
                        }
                    }
                    else {
                        schedulerFn = this._isAsync ? (value) => { setTimeout(() => generatorOrNext(value)); } :
                                (value) => { generatorOrNext(value); };
                        if (error) {
                            errorFn =
                                this._isAsync ? (err) => { setTimeout(() => error(err)); } : (err) => { error(err); };
                        }
                        if (complete) {
                            completeFn =
                                this._isAsync ? () => { setTimeout(() => complete()); } : () => { complete(); };
                        }
                    }
                    return super.subscribe(schedulerFn, errorFn, completeFn);
                }
            }
            exports_1("EventEmitter", EventEmitter);
        }
    }
});
//# sourceMappingURL=async.js.map
System.register(['angular2/src/core/zone/ng_zone', 'angular2/src/facade/lang', 'angular2/src/core/di', './application_tokens', 'angular2/src/facade/async', 'angular2/src/facade/collection', 'angular2/src/core/testability/testability', 'angular2/src/core/linker/dynamic_component_loader', 'angular2/src/facade/exceptions', 'angular2/src/core/console', './profile/profile'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var ng_zone_1, lang_1, di_1, application_tokens_1, async_1, collection_1, testability_1, dynamic_component_loader_1, exceptions_1, console_1, profile_1, lang_2;
    var _platform, _platformProviders, PlatformRef, PlatformRef_, ApplicationRef, ApplicationRef_;
    /**
     * Construct providers specific to an individual root component.
     */
    function _componentProviders(appComponentType) {
        return [
            di_1.provide(application_tokens_1.APP_COMPONENT, { useValue: appComponentType }),
            di_1.provide(application_tokens_1.APP_COMPONENT_REF_PROMISE, {
                useFactory: (dynamicComponentLoader, appRef, injector) => {
                    // Save the ComponentRef for disposal later.
                    var ref;
                    // TODO(rado): investigate whether to support providers on root component.
                    return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector, () => { appRef._unloadComponent(ref); })
                        .then((componentRef) => {
                        ref = componentRef;
                        var testability = injector.getOptional(testability_1.Testability);
                        if (lang_1.isPresent(testability)) {
                            injector.get(testability_1.TestabilityRegistry)
                                .registerApplication(componentRef.location.nativeElement, testability);
                        }
                        return componentRef;
                    });
                },
                deps: [dynamic_component_loader_1.DynamicComponentLoader, ApplicationRef, di_1.Injector]
            }),
            di_1.provide(appComponentType, {
                useFactory: (p) => p.then(ref => ref.instance),
                deps: [application_tokens_1.APP_COMPONENT_REF_PROMISE]
            }),
        ];
    }
    /**
     * Create an Angular zone.
     */
    function createNgZone() {
        return new ng_zone_1.NgZone({ enableLongStackTrace: lang_1.assertionsEnabled() });
    }
    exports_1("createNgZone", createNgZone);
    /**
     * Initialize the Angular 'platform' on the page.
     *
     * See {@link PlatformRef} for details on the Angular platform.
     *
     * It is also possible to specify providers to be made in the new platform. These providers
     * will be shared between all applications on the page. For example, an abstraction for
     * the browser cookie jar should be bound at the platform level, because there is only one
     * cookie jar regardless of how many applications on the page will be accessing it.
     *
     * The platform function can be called multiple times as long as the same list of providers
     * is passed into each call. If the platform function is called with a different set of
     * provides, Angular will throw an exception.
     */
    function platform(providers) {
        lang_2.lockMode();
        if (lang_1.isPresent(_platform)) {
            if (collection_1.ListWrapper.equals(_platformProviders, providers)) {
                return _platform;
            }
            else {
                throw new exceptions_1.BaseException("platform cannot be initialized with different sets of providers.");
            }
        }
        else {
            return _createPlatform(providers);
        }
    }
    exports_1("platform", platform);
    /**
     * Dispose the existing platform.
     */
    function disposePlatform() {
        if (lang_1.isPresent(_platform)) {
            _platform.dispose();
            _platform = null;
        }
    }
    exports_1("disposePlatform", disposePlatform);
    function _createPlatform(providers) {
        _platformProviders = providers;
        let injector = di_1.Injector.resolveAndCreate(providers);
        _platform = new PlatformRef_(injector, () => {
            _platform = null;
            _platformProviders = null;
        });
        _runPlatformInitializers(injector);
        return _platform;
    }
    function _runPlatformInitializers(injector) {
        let inits = injector.getOptional(application_tokens_1.PLATFORM_INITIALIZER);
        if (lang_1.isPresent(inits))
            inits.forEach(init => init());
    }
    function _runAppInitializers(injector) {
        let inits = injector.getOptional(application_tokens_1.APP_INITIALIZER);
        let promises = [];
        if (lang_1.isPresent(inits)) {
            inits.forEach(init => {
                var retVal = init();
                if (async_1.PromiseWrapper.isPromise(retVal)) {
                    promises.push(retVal);
                }
            });
        }
        if (promises.length > 0) {
            return async_1.PromiseWrapper.all(promises);
        }
        else {
            return null;
        }
    }
    return {
        setters:[
            function (ng_zone_1_1) {
                ng_zone_1 = ng_zone_1_1;
            },
            function (lang_1_1) {
                lang_1 = lang_1_1;
                lang_2 = lang_1_1;
            },
            function (di_1_1) {
                di_1 = di_1_1;
            },
            function (application_tokens_1_1) {
                application_tokens_1 = application_tokens_1_1;
            },
            function (async_1_1) {
                async_1 = async_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (testability_1_1) {
                testability_1 = testability_1_1;
            },
            function (dynamic_component_loader_1_1) {
                dynamic_component_loader_1 = dynamic_component_loader_1_1;
            },
            function (exceptions_1_1) {
                exceptions_1 = exceptions_1_1;
            },
            function (console_1_1) {
                console_1 = console_1_1;
            },
            function (profile_1_1) {
                profile_1 = profile_1_1;
            }],
        execute: function() {
            /**
             * The Angular platform is the entry point for Angular on a web page. Each page
             * has exactly one platform, and services (such as reflection) which are common
             * to every Angular application running on the page are bound in its scope.
             *
             * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
             * explicitly by calling {@link platform}().
             */
            class PlatformRef {
                /**
                 * Retrieve the platform {@link Injector}, which is the parent injector for
                 * every Angular application on the page and provides singleton providers.
                 */
                get injector() { return exceptions_1.unimplemented(); }
                ;
            }
            exports_1("PlatformRef", PlatformRef);
            class PlatformRef_ extends PlatformRef {
                constructor(_injector, _dispose) {
                    super();
                    this._injector = _injector;
                    this._dispose = _dispose;
                    /** @internal */
                    this._applications = [];
                    /** @internal */
                    this._disposeListeners = [];
                }
                registerDisposeListener(dispose) { this._disposeListeners.push(dispose); }
                get injector() { return this._injector; }
                application(providers) {
                    var app = this._initApp(createNgZone(), providers);
                    if (async_1.PromiseWrapper.isPromise(app)) {
                        throw new exceptions_1.BaseException("Cannot use asyncronous app initializers with application. Use asyncApplication instead.");
                    }
                    return app;
                }
                asyncApplication(bindingFn, additionalProviders) {
                    var zone = createNgZone();
                    var completer = async_1.PromiseWrapper.completer();
                    if (bindingFn === null) {
                        completer.resolve(this._initApp(zone, additionalProviders));
                    }
                    else {
                        zone.run(() => {
                            async_1.PromiseWrapper.then(bindingFn(zone), (providers) => {
                                if (lang_1.isPresent(additionalProviders)) {
                                    providers = collection_1.ListWrapper.concat(providers, additionalProviders);
                                }
                                let promise = this._initApp(zone, providers);
                                completer.resolve(promise);
                            });
                        });
                    }
                    return completer.promise;
                }
                _initApp(zone, providers) {
                    var injector;
                    var app;
                    zone.run(() => {
                        providers = collection_1.ListWrapper.concat(providers, [
                            di_1.provide(ng_zone_1.NgZone, { useValue: zone }),
                            di_1.provide(ApplicationRef, { useFactory: () => app, deps: [] })
                        ]);
                        var exceptionHandler;
                        try {
                            injector = this.injector.resolveAndCreateChild(providers);
                            exceptionHandler = injector.get(exceptions_1.ExceptionHandler);
                            zone.overrideOnErrorHandler((e, s) => exceptionHandler.call(e, s));
                        }
                        catch (e) {
                            if (lang_1.isPresent(exceptionHandler)) {
                                exceptionHandler.call(e, e.stack);
                            }
                            else {
                                lang_1.print(e.toString());
                            }
                        }
                    });
                    app = new ApplicationRef_(this, zone, injector);
                    this._applications.push(app);
                    var promise = _runAppInitializers(injector);
                    if (promise !== null) {
                        return async_1.PromiseWrapper.then(promise, (_) => app);
                    }
                    else {
                        return app;
                    }
                }
                dispose() {
                    collection_1.ListWrapper.clone(this._applications).forEach((app) => app.dispose());
                    this._disposeListeners.forEach((dispose) => dispose());
                    this._dispose();
                }
                /** @internal */
                _applicationDisposed(app) { collection_1.ListWrapper.remove(this._applications, app); }
            }
            exports_1("PlatformRef_", PlatformRef_);
            /**
             * A reference to an Angular application running on a page.
             *
             * For more about Angular applications, see the documentation for {@link bootstrap}.
             */
            class ApplicationRef {
                /**
                 * Retrieve the application {@link Injector}.
                 */
                get injector() { return exceptions_1.unimplemented(); }
                ;
                /**
                 * Retrieve the application {@link NgZone}.
                 */
                get zone() { return exceptions_1.unimplemented(); }
                ;
                /**
                 * Get a list of component types registered to this application.
                 */
                get componentTypes() { return exceptions_1.unimplemented(); }
                ;
            }
            exports_1("ApplicationRef", ApplicationRef);
            class ApplicationRef_ extends ApplicationRef {
                constructor(_platform, _zone, _injector) {
                    super();
                    this._platform = _platform;
                    this._zone = _zone;
                    this._injector = _injector;
                    /** @internal */
                    this._bootstrapListeners = [];
                    /** @internal */
                    this._disposeListeners = [];
                    /** @internal */
                    this._rootComponents = [];
                    /** @internal */
                    this._rootComponentTypes = [];
                    /** @internal */
                    this._changeDetectorRefs = [];
                    /** @internal */
                    this._runningTick = false;
                    /** @internal */
                    this._enforceNoNewChanges = false;
                    if (lang_1.isPresent(this._zone)) {
                        async_1.ObservableWrapper.subscribe(this._zone.onTurnDone, (_) => { this._zone.run(() => { this.tick(); }); });
                    }
                    this._enforceNoNewChanges = lang_1.assertionsEnabled();
                }
                registerBootstrapListener(listener) {
                    this._bootstrapListeners.push(listener);
                }
                registerDisposeListener(dispose) { this._disposeListeners.push(dispose); }
                registerChangeDetector(changeDetector) {
                    this._changeDetectorRefs.push(changeDetector);
                }
                unregisterChangeDetector(changeDetector) {
                    collection_1.ListWrapper.remove(this._changeDetectorRefs, changeDetector);
                }
                bootstrap(componentType, providers) {
                    var completer = async_1.PromiseWrapper.completer();
                    this._zone.run(() => {
                        var componentProviders = _componentProviders(componentType);
                        if (lang_1.isPresent(providers)) {
                            componentProviders.push(providers);
                        }
                        var exceptionHandler = this._injector.get(exceptions_1.ExceptionHandler);
                        this._rootComponentTypes.push(componentType);
                        try {
                            var injector = this._injector.resolveAndCreateChild(componentProviders);
                            var compRefToken = injector.get(application_tokens_1.APP_COMPONENT_REF_PROMISE);
                            var tick = (componentRef) => {
                                this._loadComponent(componentRef);
                                completer.resolve(componentRef);
                            };
                            var tickResult = async_1.PromiseWrapper.then(compRefToken, tick);
                            // THIS MUST ONLY RUN IN DART.
                            // This is required to report an error when no components with a matching selector found.
                            // Otherwise the promise will never be completed.
                            // Doing this in JS causes an extra error message to appear.
                            if (lang_1.IS_DART) {
                                async_1.PromiseWrapper.then(tickResult, (_) => { });
                            }
                            async_1.PromiseWrapper.then(tickResult, null, (err, stackTrace) => completer.reject(err, stackTrace));
                        }
                        catch (e) {
                            exceptionHandler.call(e, e.stack);
                            completer.reject(e, e.stack);
                        }
                    });
                    return completer.promise.then(_ => {
                        let c = this._injector.get(console_1.Console);
                        if (lang_1.assertionsEnabled()) {
                            c.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
                        }
                        return _;
                    });
                }
                /** @internal */
                _loadComponent(ref) {
                    var appChangeDetector = ref.location.internalElement.parentView.changeDetector;
                    this._changeDetectorRefs.push(appChangeDetector.ref);
                    this.tick();
                    this._rootComponents.push(ref);
                    this._bootstrapListeners.forEach((listener) => listener(ref));
                }
                /** @internal */
                _unloadComponent(ref) {
                    if (!collection_1.ListWrapper.contains(this._rootComponents, ref)) {
                        return;
                    }
                    this.unregisterChangeDetector(ref.location.internalElement.parentView.changeDetector.ref);
                    collection_1.ListWrapper.remove(this._rootComponents, ref);
                }
                get injector() { return this._injector; }
                get zone() { return this._zone; }
                tick() {
                    if (this._runningTick) {
                        throw new exceptions_1.BaseException("ApplicationRef.tick is called recursively");
                    }
                    var s = ApplicationRef_._tickScope();
                    try {
                        this._runningTick = true;
                        this._changeDetectorRefs.forEach((detector) => detector.detectChanges());
                        if (this._enforceNoNewChanges) {
                            this._changeDetectorRefs.forEach((detector) => detector.checkNoChanges());
                        }
                    }
                    finally {
                        this._runningTick = false;
                        profile_1.wtfLeave(s);
                    }
                }
                dispose() {
                    // TODO(alxhub): Dispose of the NgZone.
                    collection_1.ListWrapper.clone(this._rootComponents).forEach((ref) => ref.dispose());
                    this._disposeListeners.forEach((dispose) => dispose());
                    this._platform._applicationDisposed(this);
                }
                get componentTypes() { return this._rootComponentTypes; }
            }
            /** @internal */
            ApplicationRef_._tickScope = profile_1.wtfCreateScope('ApplicationRef#tick()');
            exports_1("ApplicationRef_", ApplicationRef_);
        }
    }
});
//# sourceMappingURL=application_ref.js.map
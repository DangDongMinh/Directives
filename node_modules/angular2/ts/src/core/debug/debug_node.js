System.register(['angular2/src/facade/lang', 'angular2/src/facade/collection'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var lang_1, collection_1;
    var EventListener, DebugNode, DebugElement, _nativeNodeToDebugNode;
    function asNativeElements(debugEls) {
        return debugEls.map((el) => el.nativeElement);
    }
    exports_1("asNativeElements", asNativeElements);
    function _queryElementChildren(element, predicate, matches) {
        element.childNodes.forEach(node => {
            if (node instanceof DebugElement) {
                if (predicate(node)) {
                    matches.push(node);
                }
                _queryElementChildren(node, predicate, matches);
            }
        });
    }
    function _queryNodeChildren(parentNode, predicate, matches) {
        if (parentNode instanceof DebugElement) {
            parentNode.childNodes.forEach(node => {
                if (predicate(node)) {
                    matches.push(node);
                }
                if (node instanceof DebugElement) {
                    _queryNodeChildren(node, predicate, matches);
                }
            });
        }
    }
    function getDebugNode(nativeNode) {
        return _nativeNodeToDebugNode.get(nativeNode);
    }
    exports_1("getDebugNode", getDebugNode);
    function getAllDebugNodes() {
        return collection_1.MapWrapper.values(_nativeNodeToDebugNode);
    }
    exports_1("getAllDebugNodes", getAllDebugNodes);
    function indexDebugNode(node) {
        _nativeNodeToDebugNode.set(node.nativeNode, node);
    }
    exports_1("indexDebugNode", indexDebugNode);
    function removeDebugNodeFromIndex(node) {
        _nativeNodeToDebugNode.delete(node.nativeNode);
    }
    exports_1("removeDebugNodeFromIndex", removeDebugNodeFromIndex);
    return {
        setters:[
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            }],
        execute: function() {
            class EventListener {
                constructor(name, callback) {
                    this.name = name;
                    this.callback = callback;
                }
                ;
            }
            exports_1("EventListener", EventListener);
            class DebugNode {
                constructor(nativeNode, parent) {
                    this.nativeNode = nativeNode;
                    if (lang_1.isPresent(parent) && parent instanceof DebugElement) {
                        parent.addChild(this);
                    }
                    else {
                        this.parent = null;
                    }
                    this.listeners = [];
                    this.providerTokens = [];
                }
                setDebugInfo(info) {
                    this.injector = info.injector;
                    this.providerTokens = info.providerTokens;
                    this.locals = info.locals;
                    this.componentInstance = info.component;
                }
                inject(token) { return this.injector.get(token); }
                getLocal(name) { return this.locals.get(name); }
            }
            exports_1("DebugNode", DebugNode);
            class DebugElement extends DebugNode {
                constructor(nativeNode, parent) {
                    super(nativeNode, parent);
                    this.properties = new Map();
                    this.attributes = new Map();
                    this.childNodes = [];
                    this.nativeElement = nativeNode;
                }
                addChild(child) {
                    if (lang_1.isPresent(child)) {
                        this.childNodes.push(child);
                        child.parent = this;
                    }
                }
                removeChild(child) {
                    var childIndex = this.childNodes.indexOf(child);
                    if (childIndex !== -1) {
                        child.parent = null;
                        this.childNodes.splice(childIndex, 1);
                    }
                }
                insertChildrenAfter(child, newChildren) {
                    var siblingIndex = this.childNodes.indexOf(child);
                    if (siblingIndex !== -1) {
                        var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
                        var nextChildren = this.childNodes.slice(siblingIndex + 1);
                        this.childNodes =
                            collection_1.ListWrapper.concat(collection_1.ListWrapper.concat(previousChildren, newChildren), nextChildren);
                        for (var i = 0; i < newChildren.length; ++i) {
                            var newChild = newChildren[i];
                            if (lang_1.isPresent(newChild.parent)) {
                                newChild.parent.removeChild(newChild);
                            }
                            newChild.parent = this;
                        }
                    }
                }
                query(predicate) {
                    var results = this.queryAll(predicate);
                    return results.length > 0 ? results[0] : null;
                }
                queryAll(predicate) {
                    var matches = [];
                    _queryElementChildren(this, predicate, matches);
                    return matches;
                }
                queryAllNodes(predicate) {
                    var matches = [];
                    _queryNodeChildren(this, predicate, matches);
                    return matches;
                }
                get children() {
                    var children = [];
                    this.childNodes.forEach((node) => {
                        if (node instanceof DebugElement) {
                            children.push(node);
                        }
                    });
                    return children;
                }
                triggerEventHandler(eventName, eventObj) {
                    this.listeners.forEach((listener) => {
                        if (listener.name == eventName) {
                            listener.callback(eventObj);
                        }
                    });
                }
            }
            exports_1("DebugElement", DebugElement);
            // Need to keep the nodes in a global Map so that multiple angular apps are supported.
            _nativeNodeToDebugNode = new Map();
        }
    }
});
//# sourceMappingURL=debug_node.js.map
System.register(["angular2/src/facade/collection"], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var collection_1;
    var AST, Quote, EmptyExpr, ImplicitReceiver, Chain, Conditional, PropertyRead, PropertyWrite, SafePropertyRead, KeyedRead, KeyedWrite, BindingPipe, LiteralPrimitive, LiteralArray, LiteralMap, Interpolation, Binary, PrefixNot, MethodCall, SafeMethodCall, FunctionCall, ASTWithSource, TemplateBinding, RecursiveAstVisitor, AstTransformer;
    return {
        setters:[
            function (collection_1_1) {
                collection_1 = collection_1_1;
            }],
        execute: function() {
            class AST {
                visit(visitor) { return null; }
                toString() { return "AST"; }
            }
            exports_1("AST", AST);
            /**
             * Represents a quoted expression of the form:
             *
             * quote = prefix `:` uninterpretedExpression
             * prefix = identifier
             * uninterpretedExpression = arbitrary string
             *
             * A quoted expression is meant to be pre-processed by an AST transformer that
             * converts it into another AST that no longer contains quoted expressions.
             * It is meant to allow third-party developers to extend Angular template
             * expression language. The `uninterpretedExpression` part of the quote is
             * therefore not interpreted by the Angular's own expression parser.
             */
            class Quote extends AST {
                constructor(prefix, uninterpretedExpression, location) {
                    super();
                    this.prefix = prefix;
                    this.uninterpretedExpression = uninterpretedExpression;
                    this.location = location;
                }
                visit(visitor) { return visitor.visitQuote(this); }
                toString() { return "Quote"; }
            }
            exports_1("Quote", Quote);
            class EmptyExpr extends AST {
                visit(visitor) {
                    // do nothing
                }
            }
            exports_1("EmptyExpr", EmptyExpr);
            class ImplicitReceiver extends AST {
                visit(visitor) { return visitor.visitImplicitReceiver(this); }
            }
            exports_1("ImplicitReceiver", ImplicitReceiver);
            /**
             * Multiple expressions separated by a semicolon.
             */
            class Chain extends AST {
                constructor(expressions) {
                    super();
                    this.expressions = expressions;
                }
                visit(visitor) { return visitor.visitChain(this); }
            }
            exports_1("Chain", Chain);
            class Conditional extends AST {
                constructor(condition, trueExp, falseExp) {
                    super();
                    this.condition = condition;
                    this.trueExp = trueExp;
                    this.falseExp = falseExp;
                }
                visit(visitor) { return visitor.visitConditional(this); }
            }
            exports_1("Conditional", Conditional);
            class PropertyRead extends AST {
                constructor(receiver, name, getter) {
                    super();
                    this.receiver = receiver;
                    this.name = name;
                    this.getter = getter;
                }
                visit(visitor) { return visitor.visitPropertyRead(this); }
            }
            exports_1("PropertyRead", PropertyRead);
            class PropertyWrite extends AST {
                constructor(receiver, name, setter, value) {
                    super();
                    this.receiver = receiver;
                    this.name = name;
                    this.setter = setter;
                    this.value = value;
                }
                visit(visitor) { return visitor.visitPropertyWrite(this); }
            }
            exports_1("PropertyWrite", PropertyWrite);
            class SafePropertyRead extends AST {
                constructor(receiver, name, getter) {
                    super();
                    this.receiver = receiver;
                    this.name = name;
                    this.getter = getter;
                }
                visit(visitor) { return visitor.visitSafePropertyRead(this); }
            }
            exports_1("SafePropertyRead", SafePropertyRead);
            class KeyedRead extends AST {
                constructor(obj, key) {
                    super();
                    this.obj = obj;
                    this.key = key;
                }
                visit(visitor) { return visitor.visitKeyedRead(this); }
            }
            exports_1("KeyedRead", KeyedRead);
            class KeyedWrite extends AST {
                constructor(obj, key, value) {
                    super();
                    this.obj = obj;
                    this.key = key;
                    this.value = value;
                }
                visit(visitor) { return visitor.visitKeyedWrite(this); }
            }
            exports_1("KeyedWrite", KeyedWrite);
            class BindingPipe extends AST {
                constructor(exp, name, args) {
                    super();
                    this.exp = exp;
                    this.name = name;
                    this.args = args;
                }
                visit(visitor) { return visitor.visitPipe(this); }
            }
            exports_1("BindingPipe", BindingPipe);
            class LiteralPrimitive extends AST {
                constructor(value) {
                    super();
                    this.value = value;
                }
                visit(visitor) { return visitor.visitLiteralPrimitive(this); }
            }
            exports_1("LiteralPrimitive", LiteralPrimitive);
            class LiteralArray extends AST {
                constructor(expressions) {
                    super();
                    this.expressions = expressions;
                }
                visit(visitor) { return visitor.visitLiteralArray(this); }
            }
            exports_1("LiteralArray", LiteralArray);
            class LiteralMap extends AST {
                constructor(keys, values) {
                    super();
                    this.keys = keys;
                    this.values = values;
                }
                visit(visitor) { return visitor.visitLiteralMap(this); }
            }
            exports_1("LiteralMap", LiteralMap);
            class Interpolation extends AST {
                constructor(strings, expressions) {
                    super();
                    this.strings = strings;
                    this.expressions = expressions;
                }
                visit(visitor) { return visitor.visitInterpolation(this); }
            }
            exports_1("Interpolation", Interpolation);
            class Binary extends AST {
                constructor(operation, left, right) {
                    super();
                    this.operation = operation;
                    this.left = left;
                    this.right = right;
                }
                visit(visitor) { return visitor.visitBinary(this); }
            }
            exports_1("Binary", Binary);
            class PrefixNot extends AST {
                constructor(expression) {
                    super();
                    this.expression = expression;
                }
                visit(visitor) { return visitor.visitPrefixNot(this); }
            }
            exports_1("PrefixNot", PrefixNot);
            class MethodCall extends AST {
                constructor(receiver, name, fn, args) {
                    super();
                    this.receiver = receiver;
                    this.name = name;
                    this.fn = fn;
                    this.args = args;
                }
                visit(visitor) { return visitor.visitMethodCall(this); }
            }
            exports_1("MethodCall", MethodCall);
            class SafeMethodCall extends AST {
                constructor(receiver, name, fn, args) {
                    super();
                    this.receiver = receiver;
                    this.name = name;
                    this.fn = fn;
                    this.args = args;
                }
                visit(visitor) { return visitor.visitSafeMethodCall(this); }
            }
            exports_1("SafeMethodCall", SafeMethodCall);
            class FunctionCall extends AST {
                constructor(target, args) {
                    super();
                    this.target = target;
                    this.args = args;
                }
                visit(visitor) { return visitor.visitFunctionCall(this); }
            }
            exports_1("FunctionCall", FunctionCall);
            class ASTWithSource extends AST {
                constructor(ast, source, location) {
                    super();
                    this.ast = ast;
                    this.source = source;
                    this.location = location;
                }
                visit(visitor) { return this.ast.visit(visitor); }
                toString() { return `${this.source} in ${this.location}`; }
            }
            exports_1("ASTWithSource", ASTWithSource);
            class TemplateBinding {
                constructor(key, keyIsVar, name, expression) {
                    this.key = key;
                    this.keyIsVar = keyIsVar;
                    this.name = name;
                    this.expression = expression;
                }
            }
            exports_1("TemplateBinding", TemplateBinding);
            class RecursiveAstVisitor {
                visitBinary(ast) {
                    ast.left.visit(this);
                    ast.right.visit(this);
                    return null;
                }
                visitChain(ast) { return this.visitAll(ast.expressions); }
                visitConditional(ast) {
                    ast.condition.visit(this);
                    ast.trueExp.visit(this);
                    ast.falseExp.visit(this);
                    return null;
                }
                visitPipe(ast) {
                    ast.exp.visit(this);
                    this.visitAll(ast.args);
                    return null;
                }
                visitFunctionCall(ast) {
                    ast.target.visit(this);
                    this.visitAll(ast.args);
                    return null;
                }
                visitImplicitReceiver(ast) { return null; }
                visitInterpolation(ast) { return this.visitAll(ast.expressions); }
                visitKeyedRead(ast) {
                    ast.obj.visit(this);
                    ast.key.visit(this);
                    return null;
                }
                visitKeyedWrite(ast) {
                    ast.obj.visit(this);
                    ast.key.visit(this);
                    ast.value.visit(this);
                    return null;
                }
                visitLiteralArray(ast) { return this.visitAll(ast.expressions); }
                visitLiteralMap(ast) { return this.visitAll(ast.values); }
                visitLiteralPrimitive(ast) { return null; }
                visitMethodCall(ast) {
                    ast.receiver.visit(this);
                    return this.visitAll(ast.args);
                }
                visitPrefixNot(ast) {
                    ast.expression.visit(this);
                    return null;
                }
                visitPropertyRead(ast) {
                    ast.receiver.visit(this);
                    return null;
                }
                visitPropertyWrite(ast) {
                    ast.receiver.visit(this);
                    ast.value.visit(this);
                    return null;
                }
                visitSafePropertyRead(ast) {
                    ast.receiver.visit(this);
                    return null;
                }
                visitSafeMethodCall(ast) {
                    ast.receiver.visit(this);
                    return this.visitAll(ast.args);
                }
                visitAll(asts) {
                    asts.forEach(ast => ast.visit(this));
                    return null;
                }
                visitQuote(ast) { return null; }
            }
            exports_1("RecursiveAstVisitor", RecursiveAstVisitor);
            class AstTransformer {
                visitImplicitReceiver(ast) { return ast; }
                visitInterpolation(ast) {
                    return new Interpolation(ast.strings, this.visitAll(ast.expressions));
                }
                visitLiteralPrimitive(ast) { return new LiteralPrimitive(ast.value); }
                visitPropertyRead(ast) {
                    return new PropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
                }
                visitPropertyWrite(ast) {
                    return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.setter, ast.value);
                }
                visitSafePropertyRead(ast) {
                    return new SafePropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
                }
                visitMethodCall(ast) {
                    return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
                }
                visitSafeMethodCall(ast) {
                    return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
                }
                visitFunctionCall(ast) {
                    return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
                }
                visitLiteralArray(ast) {
                    return new LiteralArray(this.visitAll(ast.expressions));
                }
                visitLiteralMap(ast) {
                    return new LiteralMap(ast.keys, this.visitAll(ast.values));
                }
                visitBinary(ast) {
                    return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
                }
                visitPrefixNot(ast) { return new PrefixNot(ast.expression.visit(this)); }
                visitConditional(ast) {
                    return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
                }
                visitPipe(ast) {
                    return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
                }
                visitKeyedRead(ast) {
                    return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
                }
                visitKeyedWrite(ast) {
                    return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
                }
                visitAll(asts) {
                    var res = collection_1.ListWrapper.createFixedSize(asts.length);
                    for (var i = 0; i < asts.length; ++i) {
                        res[i] = asts[i].visit(this);
                    }
                    return res;
                }
                visitChain(ast) { return new Chain(this.visitAll(ast.expressions)); }
                visitQuote(ast) {
                    return new Quote(ast.prefix, ast.uninterpretedExpression, ast.location);
                }
            }
            exports_1("AstTransformer", AstTransformer);
        }
    }
});
//# sourceMappingURL=ast.js.map